---
title: 程序设计 II
date: 2021-7-10 12:00:00 +0800
categories: [Program, Algorithm]
tags: [code, program, algorithm]     # TAG names should always be lowercase
math: true
toc: true
---

> 本博客是基于中国科学技术大学的马建辉老师的 PPT 修改而成

# 0. 课程概述

## 0.1. 预备知识

- 熟练使用C语言编程
- 理解和掌握结构化程序设计方法

## 0.2. 课程目标

- 加强上机实践环节,提高C语言程序设计能力
- 引导学生学习其他语言：C++/JAVA/Python
- 熟悉一种或几种C语言集成开发环境(IDE),熟练掌握编译、跟踪、调试、分析排错技术
- 初步掌握递归、回溯等程序设计方法;按照软件工程的基本规范形成良好的编程习惯

## 0.3. 教学方式

总学时:40学时/40机时+课外训练

## 0.4. 课程内容

- 第一讲:C编程规范
- 第二讲:简单计算、数制转换、日期处理
- 第三讲:字符串处理
- 第四讲:高精度计算
- 第五讲:枚举
- 第六讲:递归
- 第七讲:搜索
- 第八讲:动态规划
- 第九讲:链表和二叉树(不讲)
- 第十讲:面向对象程序设计基础(C++)
- 第十一讲:其它编程语言导引(JAVA、Python)、系统编程基础(选讲)

## 0.5. 参考书目

- 《程序设计导引及在线实践》,李文新等编著,清华大学出版社
- 《Thinking in C++(Volume One)》,Bruce Eckel,Prentice Hall ,ISBN:7-111-09162-0

## 0.6. 考核方式

上机实践(50%)+期末考试(50%)

## 0.7. 两点要求

---

# 1. C语言回顾&编程规范

## 1.1. C语言回顾

## 1.2. 标识符的命名

匈牙利命名法为C程序标识符的命名定义了一种非常标准化的方式,这种命名方式是以两条规则为基础的:
1. 变量的名字以一个或者多个小写字母前缀开头,前缀能够体现变量数据类型、作用域等信息.
2. 在标识符内,前缀以后就是一个或者多个第一个字母大写的单词,这些单词清楚地指出了该标识符的作用.

---

1. 变量命名加前缀

   | 前缀 | 类型                              |
   | ---- | --------------------------------- |
   | c    | char                              |
   | uc   | unsigned char                     |
   | s    | short                             |
   | n    | int                               |
   | u    | unsigned int                      |
   | l    | long                              |
   | dw   | unsigned long                     |
   | b    | 取值只为真和假的整型变量(boolean) |
   | sz   | 以'\0'结尾的字符串或字符数组      |
   | f    | float                             |
   | h    | HANDLE（句柄）                    |
   | d    | double                            |
   | p    | 指针                              |
   | psz  | 指向字符串的指针                  |
   | pn   | 整型指针                          |
   | m_   | 类成员变量                        |
   | g_   | 全局变量                          |
   | a    | 数组                              |
   | fp   | 文件指针 FILE *                   |
   | e    | enum类型                          |

   参数后面加'_',如

   ```c
   int Sum( int x_, int y_) {
   }
   ```

2. 变量名中单词开头字母大写,其他字母小写

   <u>但是常用的意义明显的变量,如i,j,k,坐标x,y等不必遵循1,2</u>

3. 常量和宏都是大写,单词之间用'_'分隔

   ` #define MAX_WIDTH 5`

4. 函数名字中每个单词的头一个字母大写,其他字母小写.一般采用动词+名词形式.

   ```c
   void PrintMessage();
   int WriteIdToFile( FILE * _fp, int _nId);
   ```

5. 结构定义加大写字母S作为前缀

   ```c
   struct SPerson {
       int nId;
       int nAge;
   };
   ```

6. 类定义加大写字母C作为前缀

   ```c++
   class CPerson{
       int m_nId;
   }
   ```

7. 类型定义全部大写

   ```c++
   typedef struct SPerson PERSON;
   typedef struct SPerson PPERSON; //指针加'P'
   ```

---

标识符命名应注意的一些细节:

- 标识符号应能提供足够信息,最好是可以发音的.

- 为全局变量取长的,描述信息多的名字,为局部变量取短名字.

- 名字太长时可以适当采用单词的缩写.但要注意,缩写方式要一致.要缩写就全都缩写.

  比如:单词Number, 如果在某个变量里缩写成了:` int nDoorNum;`

  那么最好包含 Number单词的变量都缩写成 Num.

- 注意使用单词的复数形式.如

  ` int nTotalStudents, nStudents;`容易让人理解成代表学生数目,而 `int nStudent;`含义就不十分明显

- 对于返回值为真或假的函数,加"Is"前缀.如:

  ```c++
  int IsCanceled();
  int Isalpha(); //C语言标准库函数
  bool IsButtonPushed();
  ```

- 对于获取某个数值的函数,加"Get"前缀.

  ```c
  char * GetFileName();
  ```

- 对于设置某个数值的函数,加"Set"前缀.

  ```c
  void SetMaxVolume();
  ```

  

- 一般变量和结构名用名词,函数名用动词或动宾词组.

## 1.3. 程序书写格式

- 正确使用缩进

  - 首先,一定要有缩进,否则代码的层次不明显.
  - 缩进应为4个空格较好.需要缩进时一律按Tab键,或一律按空格键,不要有时用Tab键缩进,有时用空格键缩进.一般开发环境都能设置一个Tab键相当于多少个空格,此时就都用Tab键

- 行宽与折行

  一行不要太长,不能超过显示区域.以免阅读不便.太长则应折行.折行最好发生在运算符前面,不要发生在运算符后面.如

  ```c
  if( condition1() && condition2()
    	&& condition3() ){
      
  }
  ```

- "{","}"位置要统一

  如果写了
  
  ```c
  if ( condition1() ){
  	DoSomething();
  }
  ```
  
  别处就不要写
  
  ```c
  if ( condition2() )
  {
      DoSomething();
  }
  ```
  
  
  
- 变量与运算符之间最好加一个空格

  ```c
  int nAge = 5;
  nAge = 4;
  if( nAge >= 4 )
      printf("%d",nAge);
  
  for( i = 0; i< 100; i ++ );
  ```


## 1.4. 好的编程习惯

- 尽量不要用立即数,而用const定义成常量,以便以后修改

  ```c
  const int MAX_STUDENTS = 20;
  struct SStudent aStudents [MAX_STUDENTS];
  //比
  struct SStudent aStudents [20];
  //好
  ```
  
  ```c
  #define TOTAL_ELEMENTS 100
  for( i < 0; i < TOTAL_ELEMENTS; i ++) {
  }
  ```

- 使用sizeof()宏,不直接使用变量所占字节数的数值

  ```c
  int nAge;
  for( j = 0; j < 100; j ++) {
      fwrite(fpFile, & nAge, 1, sizeof(int));
  }
  //比
  for( j = 0; j < 100; j ++) {
      fwrite(fpFile, & nAge, 1, 4);
  }
  //好
  ```

- 稍复杂的表达式中要积极使用括号,以免优先级理解上的混乱

  ```c
  n = k +++ j; //不好
  n = ( k ++ ) + j; //好一点
  ```

- 不易理解的表达式应分几行写

  ```c
  n = ( k ++ ) + j;
  //应该写成:
  n = k + j;
  k ++;
  ```

- 不提倡在表达式中使用?:形式,而用if-else语句替代

  ```c
  xp =  2 * k < ( n-m) ? c[k+1] : d[k--];
  //应该写成:
  if( 2 * k < (n-m))
  	xp = c[k+1];
  else
  	xp = d[k--];
  
  ```

- 嵌套的if-else语句要多使用{}

  ```c
  if( Condition1() ) 
  	if( condition2() )
          DoSomething();
  	else
  		NoCondition2();
  //不够好,应该改成:
  if( Condition1() ) {
      if( condition2() )
          DoSomething();
      else
          NoCondition2();    
  }
  ```

- 应避免 if-else的多重嵌套,而用并列的完成

  ```c
  if( Condition1() ) {
  	if ( Condition2() ) {
  		if( Condition3() ) {
  			Condition123();
  		}else  {
  			NoCondition3();
  		}
  	}else {
  		NoCondition2();
  	}
  }else {
  	NoCondiction1();
  }
  //替换为:
  if( ! condition1() ) {
  	NoCondition1();
  }else if( ! condition2() ) {
  	NoCondition2();
  }else if( ! condition3() ) {
  	NoCondition3();
  }else {
  	Condition123();
  }
  ```

- 写出来的代码应该容易读出声
  比如:

  ```c
  if( !( n > m ) && !( s > t) )
  //不如
  if( ( m <= n ) && ( t <= s ) ) 
  
  if( !( c == 'y' || c == 'z') ) 
  //不如
  if( c!= 'y' && c!= 'z');
  ```

- ……

参考书目:《C++编码规范》,陈世忠 编著,中国邮电出版社

---



# 2. 简单计算、数制转换、日期处理

## 2.1. 例题 Packets

   - 题意

     - 已知:有6\*6的大箱子和1\*1,2\*2,3\*3,4\*4,5\*5,6\*6的木块,箱子的高度和木块一样
     - 问:给定各种木块的书目,求最少需要多少个大箱子来装?

   - 例如:

     - 输入:0 0 4 0 0 1	->	输出 2
     - 输入:7 5 1 0 0 0	->	输出 1

   - 解题思想:先放大的,再放小的.

     1. 每个6\*6的木块占用一个新箱子;
     2. 每个5\*5的木块占用一个新箱子,余下可放11个1\*1的;
     3. 每个4\*4的木块占用一个新箱子,余下可放5个2\*2的;
     4. 每4个3\*3的木块占用新一个箱子,不足4个还需占一个新箱子,分情况余下不同数目的空格;
     5. 每9个2\*2的木块占一个新箱子;2\*2的木块先填空格,空格不足开新箱子;
     6. 每36个1\*1的木块占一个新箱子;空格不足开新箱子.

         ```c++
         #include<iostream>
         using namespace std;
         int main(){
         	int b6, b5, b4, b3, b2, b1;	//木块数
             int nTotal = 0;				//箱子总数
             int c1;						//当前能放1*1木块的空格数目
             int c2;						//当前能放2*2木块的空格数目
             //3*3木块数目除以4的余数分别是0,1,2,3时能产生多少个能放2*2木块的空格
             int Contain2[4] = { 0, 5, 3, 1 };
             while(1){
                 cin>>b1>>b2>>b3>>b4>>b5>>b6;
                 if(b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0 && b5 == 0 && b6 == 0)
                     break;
                 nTotal = b6 + b5 + b4 +(b3 + 3)/4;
                 //技巧 - (b3+3)/4等于b3/4向上取整
                 c2 = 5 * b4 + Contain2[b3 % 4];
                 if(b2 > c2)	nTotal += (b2 - c2 + 8) / 9;
                 c1 = 36 * nTotal - 36 * b6 - 25 * b5 - 16 * b4 - 9 * b3 - 4 * b2;
                 if(b1 > c1)	nTotal += (b1 - c1 + 35) / 35;
                 cout<<nTotal<<endl;
          	}
             return 0;
         }
         ```
         
         

## 2.2. 例题 确定进制

   - 题意

     - 写一段程序读入三个整数p,q和r,然后确定一个进制B(2<=B<=16)使得p*q=r

     - 如果B有很多选择,输出最小的一个

     - 如果没有合适的进制,则输出0

     - 例如:

       p = 11 , q = 11 , r = 121

       有(11)~3~ \* (11)~3~ = (121)~3~ 和 (11)~10~ \* (11)~10~ = (121)~10~

       应该输出3

   - 输入:

     - T组输入样例(T在第一行给出)
     - 每一组测试样例占一行,包含三个整数p , q , r.
     - p , q , r 的所有位都是数字,并且1 <= p , q , r <= 100,000

   - 输出:

     - 对于每个测试样例输出一行.
     - 该行包含一个整数,即使得 p * q = r 的最小的进制B
     - 如果没有合适的B,则输出 0.
     
- 样例:

  - 输入样例

    ```
    3
    6 9 42
    11 11 121
    2 2 2
    ```

  - 输出样例

    ```
    13
    3
    0
    ```

- 解法:

  ```c
  #include <stdio.h>
  #include <string.h>
  int b2ten(int x, int b); //进制转换函数
  int main(void) {
      int p,q,r;
      int n;	//输入样例数目
      int b;
      scanf("%d", &n);
      while(n --){
          scanf("%d%d%d", &p, &q, &r);
          for( b = 2; b <= 16; b++){
              long p2 = b2ten(p,b);
              long q2 = b2ten(q,b);
              long r2 = b2ten(r,b);
              if( p2 == -1 || q2 == -1 || r2 == -1) continue;
              if( p2 * q2 == r2){
                  printf("%d\n", b);
                  break;
              }
          }
          if( b == 17) printf("0\n");
      }
      return 0;
  }
  //进制转换函数
  int b2ten( int x, int b){
      char tmp[100];
      int ret = 0;
      sprintf( tmp, "%d", x);
      int len = strlen(tmp);//空间换时间
      for( int i = 0; i < len; i ++){
          if( tmp[i] - '0' >= b) return -1;//x不是b进制数
          ret *= b;
          ret += tmp[i] - '0';
      }
      return ret;
  }
  ```

## 2.3. 例题 日历问题

- 问题描述:

  - 在我们现在使用的日历中, 闰年被定义为能被4整除的年份,但是能被100整除,而不能被400整除的年是例外,它们不是闰年.例如:1700, 1800, 1900 和 2100 不是闰年,而 1600, 2000 和 2400是闰年.
  - 给定从公元2000年1月1日开始逝去得天数,你的任务是给出这一天是哪年哪月哪日星期几.

- 输入:

  - 输入包含若干行,每行包含一个正整数,表示从2000年1月1日开始逝去的天数.
  - 输入最后一行是−1, 不必处理.
  - 可以假设结果的年份不会超过9999.

- 输出:

  - 对每个测试样例,输出一行,该行包含对应的日期和星期几.
  - 格式为“YYYY-MM-DD DayOfWeek”
  -  “DayOfWeek” 必须是下面中的一个: "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday" and "Saturday“.

- 样例:

  - 样例输入:

    ```
    1730 
    1740 
    1750 
    1751 
    -1 
    ```

  - 样例输出:

    ```
    2004-09-26 Sunday 
    2004-10-06 Wednesday 
    2004-10-16 Saturday 
    2004-10-17 Sunday
    ```

- 基本思路:

  1. 确定星期几;
  2. 确定年;闰年366天,否则365天
  3. 确定月;每个月长短不同
  4. 确定日.

  ```c++
  #include <stdio.h>
  int type(int );
  
  char week[7][10]={"Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"};
  
  int year[2]={365,366}; 
  //year[0]表示非闰年的天数,year[1]表示闰年的天数.
  
  int month[2][12]={31,28,31,30,31,30,31,31,30,31,30,31,
  			31,29,31,30,31,30,31,31,30,31,30,31};
  //month[0]表示非闰年里每个月的天数,month[1]表示闰年里每个月的天数.
  
  int main(void){  
  	int days, dayofweek;//days 表示输入的天数,dayofweek表示星期几.
  	int i = 0, j = 0;
  	while (scanf("%d", &days) && days != -1) {
  	    dayofweek = days % 7;
  	    for(i = 2000; days >= year[type(i)]; i++)
  		    days -= year[type(i)];
  	    for(j = 0; days >= month[ type(i) ][ j ]; j++)
  		    days -= month[ type(i) ][ j ];
  	    printf("%d-%02d-%02d %s\n",
  		 i, j + 1, days + 1, week[dayofweek]);
  	}
  	return 0;
  }
  
  int type(int m){ //判断第m年是否是闰年,是则返回1,否则返回0.
  	if(m % 4 != 0 || (m % 100 == 0 && m % 400 != 0)) return  0;  //不是闰年
  	else return 1;   // 是闰年
  }
  
  ```

---



# 3. 字符串处理

## 3.1. 字符串

- 每个字符串是一个特殊的数组,满足两个条件

  - 元素的类型为char
  - 最后一个元素的值为'\0',Ascii码就是0 

- 以字符型数组存储

  - 从0号元素开始存储
  - 最大可以存储长度为N-1的字符串,N是数组的大小.

- 字符串“hello”在长度为10的字符串数组中的存储

  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | H    | e    | l    | l    | o    | \0   |      |      |      |      |

## 3.2. 字符串处理函数

- 将格式化数据写入字符串：sprintf
- 字符串长度查询函数: strlen
- 字符串复制函数：strcpy、strncpy
- 字符串连接函数: strcat
- 字符串比较函数: strcmp、strncmp、stricmp、strnicmp
- 字符串搜索函数: strcspn、strspn、strstr、strtok、strchr
- 字符串大小写转换函数: strlwr、strupr

这些函数都要求` #include <string.h>`

## 3.3. 例题 Caesar密码

- 问题描述

  - Julius Caesar 生活在充满危险和阴谋的年代.为了生存,他首次发明了密码,用于军队的消息传递

  - 假设你是Caesar 军团中的一名军官,需要把Caesar 发送的消息破译出来、并提供给你的将军.消息加密的办法是:对消息原文中的每个字母,分别用该字母之后的第5个字母替换(例如:消息原文中的每个字母A都分别替换成字母F,V替换成A,W替换成B…),其他字符不 变,并且消息原文的所有字母都是大写的.

| 密码字母 | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | M    | N    | O    | P    | Q    | R    | S    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|          | T    | U    | V    | W    | X    | Y    | Z    |      |      |      |      |      |      |      |      |      |      |      |      |
| 原文字母 | V    | W    | X    | Y    | Z    | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | M    | N    |
|          | O    | P    | Q    | R    | S    | T    | U    |      |      |      |      |      |      |      |      |      |      |      |      |

- 输入

  - 最多不超过100个数据集组成.
  - 每个数据集由3部分组成:
    - 起始行：START
    - 密码消息:由1到200个字符组成一行,表示Caesar发出的一条消息
    - 结束行：END
  - 在最后一个数据集之后,是另一行：ENDOFINPUT

- 输出

  - 每个数据集对应一行,是Caesar 的原始消息.

- 样例

  - 样例输入:

    ```
    START
    NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX 
    END 
    START 
    N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ 
    END 
    START 
    IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ 
    END 
    ENDOFINPUT 
    ```

  - 样例输出:

    ```
    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES
    I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME
    DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE 
    ```

- 解答:

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  int main()   {
  	char szLine[300];
  	while( cin.getline(szLine,210) ) {  //可用此方式判断数据是否读完
  	/*cin.getline 读取一行,第一个参数是缓冲区地址;第二个参数是缓冲区大小,为了防止越界用的.	缓冲区不够大,就自动截断.它会自动往缓冲区末尾添加 ‘\0’.*/
  		if( strcmp( szLine,"ENDOFINPUT") == 0)  break;
  		cin.getline(szLine,210); //读取密文
  		for( int i = 0; szLine[i]; i ++ ) 
  			if( szLine[i] >= 'A' && szLine[i] <= 'Z' ) {
  				szLine[i] -= 5;
  				if( szLine[i] < 'A' )
  		 		  szLine[i] = 'Z' - ('A' - szLine[i])  + 1;
  			}
  		cout << szLine << endl;
  		cin.getline(szLine,210);     //读取 END
  	} 	return 0;
  }
  ```

## 3.4. 例题 子串

- 问题描述:

  给出一些由英文字符组成的大小写敏感的字符串的集合s,请找到一个最长的字符串x,使得对于s中任意字符串y,x或者是y的子串,或者x中的字符反序之后得到的新字符串是y的子串. 

- 输入:

- 输入的第一行是一个整数t ($$1\le t \le10$$),t表示测试数据的数目.对于每一组测试数据,第一行是一个整数n ($$1\le n\le100$$),表示已经给出n个字符串.接下来n行,每行给出一个长度在1和100之间的字符串.

- 输出:

  对于每一组测试数据,输出一行,给出题目中要求的字符串x的长度. 

- 样例:

  - 样例输入:

    ```
    2
    3
    ABCD
    BCDFF
    BRCD
    2
    rose
    orchid
    ```

  - 样例输出:

    ```
    2
    2
    ```

- 思路:

  - 拿输入数据中最短的字符串,从长到短找出它的所有子串,直到找到符合题意的子串

- 解法:

  ```c
  #include <stdio.h>
  #include <string.h>
  int t, n;
  char str[100][101];
  int searchMaxSubString(char* source);
  int main(){
      int i, minStrLen, subStrLen;
      char minStr[101];
      scanf("%d", &t);
      while(t--) {
          scanf("%d", &n);
  		minStrLen = 100; //记录输入数据中最短字符串的长度
  		for (i = 0; i < n; i++) {//输入一组字符串
  			scanf("%s", str[i]);
  			if ( strlen(str[i]) < minStrLen ) {//找其中最短字符串
  				strcpy(minStr, str[i]);
  				minStrLen = strlen(minStr);
  			}
  		}
  		subStrLen = searchMaxSubString(minStr);//找答案
  		printf("%d\n", subStrLen);		
  	}
      return 0;
  }
  
  int searchMaxSubString(char* source) {
      int subStrLen = strlen(source), sourceStrLen = strlen(source);
      int i, j;
      bool foundMaxSubStr;
      char subStr[101], revSubStr[101];
      while(subStrLen > 0){//搜索不同长度的子串,从最长的子串开始搜索
  		for (i = 0; i <= sourceStrLen - subStrLen; i++) {
              //搜索长度为subStrLen的全部子串
  			strncpy(subStr, source+i, subStrLen);
  			strncpy(revSubStr, source+i, subStrLen);
  			subStr[subStrLen] = revSubStr[subStrLen] = '\0'; 
  			_strrev(revSubStr);   foundMaxSubStr = true;
  			for( j = 0; j < n; j++)  //遍历所有输入的字符串
  			      if ( strstr(str[j], subStr) == NULL && 
  				strstr(str[j], revSubStr) == NULL ) {
  					foundMaxSubStr = false;
  					break;
  			}
  			if (foundMaxSubStr)  return subStrLen;
  		}
  		subStrLen--;
      }
      return 0;
  }
  ```

---



# 4. 高精度计算

## 4.1. 例题 大整数加法

- 问题描述

  求两个不超过200位的非负整数的和.

- 输入数据

  有两行,每行是一个不超过200位的非负整数,没有多余的前导0.

- 输出要求

  一行,即相加后的结果.结果里不能有多余的前导0,即如果结果是342,那么就不能输出为0342.

- 样例

  - 样例输入

    ```
    222222222222222222222222222222222
    333333333333333333333333333333333
    ```

  - 样例输出

    ```
    555555555555555555555555555555555
    ```

- 解法

  1. 用字符型或整型数组来存放大整数

     `an[0]`存放个位数,`an[1]`存放十位数,`an[2]`存放百位数……

  2. 模拟竖式加法,从个位开始逐位相加,超过或达到10则进位

     用`unsigned an1[201]`保存第一个数,用`unsigned an2[200]`表示第二个数,然后逐位相加,相加的结果直接存放在an1中.要注意处理进位.
  
  ```c
  #include <stdio.h>
  #include <string.h>
  #define MAX_LEN 201
  int an1[MAX_LEN + 10];
  int an2[MAX_LEN + 10];
  char szLine1[MAX_LEN + 10];
  char szLine2[MAX_LEN + 10];
  int Add(int nMaxLen, int * an1, int * an2) {
      //将长度最多为nMaxLen的最大整数an1和an2相加,结果放在an1,an1[0],an2[0]对应于个位
      int nHighestPos = 0;
      for(int i = 0; i < nMaxLen; i ++) {
          an1[i] += an2[i];		//逐位相加
  		if( an1[i] >= 10 ) {		//看是否要进位	
  			an1[i] -= 10;
  			an1[i+1] ++;			//进位
  		}
  		if( an1[i] )
  			nHighestPos = i; //记录最高位的位置
      }
      return nHighestPos;
  }
  
  int main(void)   {
  	scanf("%s", szLine1);  scanf("%s", szLine2);
  	int i, j;
  	//库函数memeset将地址an1开始的sizeof(an1)字节内容置成0
  	//sizeof(an1)的值就是an1的长度
  	//memset函数在string.h中声明
  	memset( an1, 0, sizeof(an1));	
  	memset( an2, 0, sizeof(an2));
  	//下面将szLine1中存储的字符串形式的整数转换到an1中去,
  	//an1[0]对应于个位
  	int nLen1 = strlen( szLine1);
  	for(j =0, i = nLen1 - 1;i >= 0 ; i --)
  		an1[j++] = szLine1[i] - '0';	
  	int nLen2 = strlen(szLine2);
  	for(j=0, i = nLen2 - 1;i >= 0 ; i --)
  		an2[j++] = szLine2[i] - '0';
  	int nHighestPos = Add(MAX_LEN,an1,an2);	
  	for( i = nHighestPos; i >= 0; i -- )  printf("%d", an1[i]);
  	return 0;
  }
  ```

## 4.2. 例题 大整数减法

- 问题描述

  求2个大的正整数相减的差

- 输入数据

  第1行是测试数据的组数n,每组测试数据占2行,第1行是被减数a,第2行是减数b(a > b).每组测试数据之间有一个空行,每行数据不超过100个字符

- 输出要求

  n行,每组测试数据有一行输出是相应的整数差

- 样例

  - 样例输入

    ```
    2 
    9999999999999999999999999999999999999 
    9999999999999 
    
    5409656775097850895687056798068970934546546575676768678435435345 
    1
    ```

  - 样例输出

    ```
    9999999999999999999999990000000000000
    5409656775097850895687056798068970934546546575676768678435435344 
    ```

  - 解法

    ```c
    #include <stdio.h>
    #include <string.h>
    #define MAX_LEN 110
    int an1[MAX_LEN];
    int an2[MAX_LEN];
    char szLine1[MAX_LEN];
    char szLine2[MAX_LEN];
    int Substract( int nMaxLen, int * an1, int * an2) {
        //两个最多nMaxLen位的大整数an1减去an2, an1保证大于an2
    	int nStartPos = 0;
    	for( int i = 0;i < nMaxLen ; i ++ ) {	
    		an1[i] -= an2[i];  //逐位减
    		if( an1[i] < 0 ) { //看是否要借位
    			an1[i] += 10;
    			an1[i+1] --; //借位
    		}
    		if( an1[i] )
    			nStartPos = i; //记录最高位的位置
    	}
    	return nStartPos; //返回值是结果里面最高位的位置
    }
    int main(void)
    {
    	int n;
    	scanf("%d",&n);
    	while(n -- ) {
    		scanf("%s", szLine1);
    		scanf("%s", szLine2);
    		int i, j;
    		memset( an1, 0, sizeof(an1));	
    		memset( an2, 0, sizeof(an2));
    		//下面将szLine1中存储的字符串形式的整数转换到an1中去,
    		//an1[0]对应于个位
    		int nLen1 = strlen( szLine1);
    		for(j = 0, i = nLen1 - 1;i >= 0 ; i --)
    			an1[j++] = szLine1[i] - '0';	
    		int nLen2 = strlen(szLine2);
    		for( j = 0, i = nLen2 - 1;i >= 0 ; i --)
    			an2[j++] = szLine2[i] - '0';
    		int nStartPos = Substract( MAX_LEN, an1,an2);
    		for( i = nStartPos; i >= 0; i -- ) 
    			printf("%d", an1[i]);
    		printf("\n");
    	}
        return 0;
    }
    ```

## 4.3. 例题 大整数乘法

- 问题描述

  求两个不超过200位的非负整数的积

- 输入数据

  有两行,每行是一个不超过200位的非负整数,没有多余的前导0

- 输出要求

  一行,即相乘后的结果.结果里不能有多余的前导0,即如果结果是342,那么就不能输出为0342

- 样例

  - 样例输入

    ```
    12345678900
    98765432100
    ```

  - 样例输出

    ```
    1219326311126352690000
    ```

- 解题思路

  -  用`unsigned an1[200]`和`unsigned an2[100]`分别存放两个乘数,用`aResult[400]`来存放积.

    计算的中间结果也都存在`aResult`中.

    `aResult`长度取400是因为两个200位的数相乘,积最多会有400位.`an1[0]`, `an2[0]`, `aResult[0]`都表示个位.

  - 一个数的第i位和另一个数的第j位相乘所得的数,一定是要累加到结果的第i+j位上.这里i, j都是从右往左,从0开始数.

  以$$ 835\times35$$为例来说明程序的计算过程.

  - 先算$$835\times9$$.$$5\times9$$得到45个1,$$3\times9$$得到27个10,$$8\times9$$得到72个100

    | 下标    | 5    | 4    | 3    | 2    | 1    | 0    |
    | ------- | ---- | ---- | ---- | ---- | ---- | ---- |
    | aResult | 0    | 0    | 0    | 72   | 27   | 45   |

  - 接下来算$$4\times5$$.此处$$4\times5$$的结果代表20个10,因此要 `aResult[1]+=20`,变为:

    | 下标    | 5    | 4    | 3    | 2    | 1      | 0    |
    | ------- | ---- | ---- | ---- | ---- | ------ | ---- |
    | aResult | 0    | 0    | 0    | 72   | **47** | 45   |

  - 再下来算$$4\times3$$.此处$$4\times3$$的结果代表12个100,因此要 `aResult[2]+= 12`,变为:

    | 下标    | 5    | 4    | 3    | 2      | 1    | 0    |
    | ------- | ---- | ---- | ---- | ------ | ---- | ---- |
    | aResult | 0    | 0    | 0    | **84** | 47   | 45   |

  - 最后算$$4\times8$$.此处$$4\times8$$的结果代表 32个1000,因此要 `aResult[3]+= 32`,变为:

    | 下标    | 5    | 4    | 3      | 2    | 1    | 0    |
    | ------- | ---- | ---- | ------ | ---- | ---- | ---- |
    | aResult | 0    | 0    | **32** | 84   | 47   | 45   |
    
  - 乘法过程完毕.接下来从 `aResult[0]`开始向高位逐位处理进位问题.`aResult[0]`留下5,把4加到`aResult[1]`上,`aResult[1]`变为51后,应留下1,把5加到`aResult[2]`上……最终使得`aResult`里的每个元素都是1位数,结果就算出来了:

    | 下标    | 5    | 4    | 3    | 2    | 1    | 0    |
    | ------- | ---- | ---- | ---- | ---- | ---- | ---- |
    | aResult | 0    | 4    | 0    | 9    | 1    | 5    |

- 解法

  ```c
  #include <stdio.h>
  #include <string.h>
  #define MAX_LEN 200
  unsigned an1[MAX_LEN+10];
  unsigned an2[MAX_LEN+10];
  unsigned aResult[MAX_LEN * 2 + 10];
  char szLine1[MAX_LEN+10];
  char szLine2[MAX_LEN+10];
  int main(void)
  {
  	gets( szLine1); //gets函数读取一行
  	gets( szLine2);
  	int i, j;
  	int nLen1 = strlen( szLine1);
  	memset( an1, 0, sizeof(an1));
  	memset( an2, 0, sizeof(an2));
  	memset( aResult, 0, sizeof(aResult));	
  	j = 0;
  	for( i = nLen1 - 1;i >= 0 ; i --)
  		an1[j++] = szLine1[i] - '0';
  	int nLen2 = strlen(szLine2);
  	j = 0;
  	for( i = nLen2 - 1;i >= 0 ; i --)
  		an2[j++] = szLine2[i] - '0';
  	//每一轮都用an1的一位,去和an2各位相乘,从an1的个位开始
  	for( i = 0;i < nLen2; i ++ ) 	{				
  		//用选定的an1的那一位,去乘an2的各位 
  		for( j = 0; j < nLen1; j ++ ) 			
  			//两数第i, j位相乘,累加到结果的第i+j位
  			aResult[i+j] += an2[i]*an1[j]; 	
  	}
  	//下面的循环统一处理进位问题
  	int nHighestPos = 0;
  	for( i = 0; i < MAX_LEN * 2; i ++ )	{
  		if( aResult[i] >= 10 ) {
  			aResult[i+1] += aResult[i] / 10;
  			aResult[i] %= 10;
  		}
  		if( aResult[i] )	nHighestPos = i;
  	}
  	for( i = nHighestPos; i >= 0; i -- )
  		printf("%d", aResult[i]);
  	return 0;
  }
  
  ```

## 4.4. 例题 大整数除法

- 问题描述

  求2个大的正整数相除的商

- 输入数据

  第1行是测试数据的组数n,每组测试数据占2行,第1行是被除数,第2行是除数.每组测试数据之间有一个空行,每行数据不超过100个字符

- 输出要求

  n行,每组测试数据有一行输出是相应的整数商

- 样例

  - 样例输入

    ```
    3 
    2405337312963373359009260457742057439230496493930355595797660791082739646 2987192585318701752584429931160870372907079248971095012509790550883793197894 
    
    10000000000000000000000000000000000000000 
    10000000000
    
    5409656775097850895687056798068970934546546575676768678435435345 
    1 
    ```

  - 样例输出

    ```
    0 
    1000000000000000000000000000000 5409656775097850895687056798068970934546546575676768678435435345 
    ```

- 思路

  基本的思想是**反复做减法**,看看从被除数里最多能减去多少个除数,商就是多少.**一个一个减显然太慢,如何减得更快一些呢?**以7546除以23为例来看一下:开始商为0.先减去23的100倍,就是2300,发现够减3次,余下646.于是商的值就增加300.然后用646减去230,发现够减2次,余下186,于是商的值增加20.最后用186减去23,够减8次,因此最终商就是328.

  <u>所以本题的核心是要写一个大整数的减法函数,然后反复调用该函数进行减法操作.</u>

- 解法

  ```c
  #include <stdio.h>
  #include <string.h>
  #define MAX_LEN 110
  int an1[MAX_LEN];
  int an2[MAX_LEN];
  int tmpAn2[MAX_LEN];
  int anResult[MAX_LEN];
  char szLine1[MAX_LEN];
  char szLine2[MAX_LEN];
  char szNouse[MAX_LEN];
  int Substract( int nMaxLen, int * an1, int * an2)
  //大整数an1减去an2.两者最多 nMaxLen 位,an1必须不小于an2, 差放在an1里
  //返回差的最高非0位的位置
  {	int nStartPos = 0;
  	for( int i = 0;i < nMaxLen ; i ++ ) {	
  		an1[i] -= an2[i];		//逐位相
  		if( an1[i] < 0 ) {		//看是否要进位	
  			an1[i] += 10;
  			an1[i+1] --;	//进位
  		}
  		if( an1[i] )
  			nStartPos = i; //记录最高位的位置
  	}
  	return nStartPos;
  }
  int Length( int nMaxLen,int * an)
  //求大整数的位数.0 算 0 位
  {	
  	int i;
  	for( i = nMaxLen -1 ; an[i] == 0 && i >= 0; i -- );
  	if( i >= 0 )
  		return i + 1;
  	return 0;
  }
  void ShiftLeft( int nMaxLen,int * an1, int * an2, int n)
  //将大整数an1左移n位,即乘以10的n次方,结果放到an2里
  {
  	memcpy( an2,an1,nMaxLen * sizeof(int));
  	if( n <= 0 )
  		return;
  	for( int i = nMaxLen -1 ; i >= 0; i -- )
  		if( i - n >= 0)
  			an2[i] = an1[i-n];
  		else
  			an2[i] = 0;
  }
  int * Max(int nMaxLen, int * an1, int * an2)
  //求大整数an1和an2里面大的那个
  //如果都是0,则返回NULL
  {
  	bool bBothZero = true;
  	for( int i = nMaxLen -1; i >= 0 ; i -- ) {
  		if( an1[i] > an2[i] )
  			return an1;
  		else if( an1[i] < an2[i] )
  			return an2;
  		else if( an1[i] )
  			bBothZero = false;
  	}
  	if( bBothZero)
  		return NULL;
  	return an1;
  }
  int main(void)
  {
  	int n;
  	scanf("%d",&n);
  	gets(szNouse);
  	while(n -- ) {
  		gets(szLine1);
  		gets(szLine2);
  		gets(szNouse);
  		int i, j;
  		//库函数memeset将地址an1开始的sizeof(an1)字节内容置成0
  		//sizeof(an1)的值就是an1的长度
  		//memset函数在string.h中声明
  		memset( an1, 0, sizeof(an1));	
  		memset( an2, 0, sizeof(an2));
  		//下面将szLine1中存储的字符串形式的整数转换到an1中去,
  		//an1[0]对应于个位
  		int nLen1 = strlen( szLine1);
  		for(j = 0, i = nLen1 - 1;i >= 0 ; i --)
  			an1[j++] = szLine1[i] - '0';	
  		int nLen2 = strlen(szLine2);
  		for( j = 0, i = nLen2 - 1;i >= 0 ; i --)
  			an2[j++] = szLine2[i] - '0';
  		int nHighestPos = 0;
  		memset(anResult,0,sizeof(anResult));
  		int nShiftLen = Length(MAX_LEN,an1) - Length(MAX_LEN,an2);
  		//只要an1大于an2,就不停相减
  		while( Max(MAX_LEN,an1,an2) == an1 ) {
  			//算出an1的10的nShiftLen次方倍
  			ShiftLeft(MAX_LEN, an2, tmpAn2,nShiftLen);
  			//重复减去an1的10的nShiftLen次方倍,看能减几次
  			while( Max(MAX_LEN,an1,tmpAn2) == an1) {
  				Substract(MAX_LEN, an1,tmpAn2);
  				//记录商对应位
  				anResult[nShiftLen] ++;
  			}
  			//记录结果最高位的位置
  			if( nHighestPos == 0 && anResult[nShiftLen])
  				nHighestPos = nShiftLen;
  			nShiftLen --;
  		}
  		for( i = nHighestPos; i >= 0; i -- ) 
  			printf("%d", anResult[i]);
  		printf("\n");
  	}
      return 0;
  }
  ```

## 4.5. 例题 循环数

- 问题描述

  当一个N位的整数X满足下列条件时,称其为循环数：X与任意一个整数$$1\le Y\le N$$相乘时,都将产生一个X的“循环”.即:分别将这两个整数的第1位数字与最后1位数字连在一起,可以得到一个相同的数字循环;当然两个整数在该数字循环中的起始位置不同.

  例如,142857是一个循环数
  $$
  142857\times1 = 142857\\ 
  142857\times2 = 285714\\ 
  142857\times3 = 428571\\ 
  142857\times4 = 571428\\ 
  142857\times5 = 714285\\ 
  142857\times6 = 857142
  $$

- 输入数据

  写一个程序判断一个整数是否是循环数.输入文件是一个整数序列,每个整数长度为2~60.注意:每个整数前面的零被看作是该整数的一部分,在计算N时要统计.例如“01”是一个2位的整数,而“1”是一个1位的整数.

- 输出要求

  对每个输入整数,输出一行,说明该整数是否是循环数.

- 样例

  - 样例输入

    ```
    142857 
    142856 
    142858 
    01 
    0588235294117647 
    ```

  - 样例输出

    ```
    142857 is cyclic 
    142856 is not cyclic 
    142858 is not cyclic 
    01 is not cyclic 
    0588235294117647 is cyclic
    ```

  - 解题思路

    - 高精度的乘法:整数可能达60位
    - Y~i~是否是X的“循环”?
      - 穷举：N位整数,循环移位可以有N种可能
      - 循环移位方法：Y~i~是否是“XX”的子串?

  - 解法

    ```c
    #include <stdio.h>
    #include <string.h>
    #define MAX_LEN 201
    int an1[MAX_LEN+10];
    int an2[MAX_LEN+10];
    char szLine1[MAX_LEN+10];
    char szLine2[MAX_LEN+10];
    char szDouble[2 * MAX_LEN + 10];
    int Add(int nMaxLen , int * an1, int * an2)
    //将长度最多为 nMaxLen 的大整数 an1和an2 相加,结果放在an1
    //an1[0],an2[0]对应于个位
    {
    	int nHighestPos = 0;
    	for(int i = 0;i < nMaxLen; i ++ ) {	
    		an1[i] += an2[i];		//逐位相加
    		if( an1[i] >= 10 ) {		//看是否要进位	
    			an1[i] -= 10;
    			an1[i+1] ++;			//进位
    		}
    		if( an1[i] )
    			nHighestPos = i; //记录最高位的位置
    	}
    	return nHighestPos;
    }
    int main(void)
    {
    	while( gets( szLine1 ) && szLine1[0] ) {
    		int i, j;
    	//库函数memeset将地址an1开始的sizeof(an1)字节内容置成0
    		//sizeof(an1)的值就是an1的长度
    		//memset函数在string.h中声明
    		memset( an1, 0, sizeof(an1));	
    		memset( an2, 0, sizeof(an1));	
    	//下面将szLine1中存储的字符串形式的整数转换到an1中去,
    		//an1[0]对应于个位
    		int nLen1 = strlen( szLine1);
    		for(j = 0, i = nLen1 - 1;i >= 0 ; i --) {
    			an1[j] = szLine1[i] - '0';	
    			an2[j++] = szLine1[i] - '0';	
    		}
    		strcpy( szDouble, szLine1);
    		strcat( szDouble, szLine1);
    		bool bOk = true;
    		for( i = 1; i < nLen1; i ++ ) {
    			int nHighestPos = Add(MAX_LEN,an1,an2);
    			if ( nHighestPos >= nLen1 ) { //长度超出了
    				bOk = false;
    				break;
    			}
    			for( int k = 0; k < nLen1; k ++ )  //转换成字符串
    				szLine2[nLen1- k - 1] = an1[k] + '0';				szLine2[nLen1] = 0;
    			if( strstr( szDouble ,szLine2 ) == NULL ) {
    				bOk = false;
    				break;
    			}
    		}
    		if( bOk) 
    			printf( "%s is cyclic\n",szLine1);
    		else
    			printf( "%s is not cyclic\n",szLine1);
    	}
        return 0;
    }
    ```


---



# 5. 枚举

枚举:

- 一种解决问题的方法.

  例如:求小于N的最大素数

  - 找不到一个数学公式,使得我们根据N就可以计算出这个素数
  - N-1是素数吗？N-2是素数吗?……N-K是素数的充分必要条件是：N-K不能被任何一个大于1、小于N-K的素数整除.
  - 判断N-K是否是素数的问题又成了求小于N-K的全部素数
  - 解决方法:
    - 2是素数,记为PRIM~0~
    - l根据PRIM~0~,PRIM~1~,… ,PRIM~k~ ,寻找比PRIM~k~大的最小素数PRIM~k+1~.如果PRIM~k+1~大于N,则PRIM~k~是我们需要找的素数,否则继续寻找

- 枚举的思想:猜测

  - 根据所知道的**知识**,给一个猜测的答案.<u>2是素数.</u>
  - 判断猜测的答案是否正确.<u>2是小于N的最大素数吗?</u>
    - 进行**新**的猜测:有两个猜测的结果必须是前面的猜测中没有出现过的.<u>每次猜测是素数一定比已经找到的素数大.</u>
    - 猜测的过程中要及早排除错误的答案.<u>除2之外,只有奇数才可能是素数.</u>
  - 关键因素要注意

## 5.1. 例题 称硬币

- 问题描述

  赛利有12枚银币.其中有11枚真币和1枚假币.假币看起来和真币没有区别,但是重量不同.但赛利不知道假币比真币轻还是重.于是他向朋友借了一架天平.朋友希望赛利称三次就能找出假币并且确定假币是轻是重.例如:如果赛利用天平称两枚硬币,发现天平平衡,说明两枚都是真的.如果赛利用一枚真币与另一枚银币比较,发现它比真币轻或重,说明它是假币.经过精心安排每次的称量,赛利保证在称三次后确定假币.

- 输入

  输入有三行,每行表示一次称量的结果.赛利事先将银币标号为A-L.每次称量的结果用三个以空格隔开的字符串表示:天平左边放置的硬币 天平右边放置的硬币 平衡状态.其中平衡状态用"up","down", 或"even"表示, 分别为右端高、右端低和平衡.天平左右的硬币数总是相等的.

- 输出

  输出哪一个标号的银币是假币,并说明它比真币轻还是重. 

- 样例

  - 样例输入

    ```
    1
    ABCD EFGH even
    ABCI EFJK up
    ABIJ EFGH even
    ```

  - 样例输出

    ```
    K is the counterfeit coin and it is light.
    ```

- 问题分析

  - [x] 此题并非要求你给出如何称量的方案,而是数据已经保证三组称量后答案唯一.不是那道传统的智商测验题.
  - [x] 此题可以有多种解法,这里只介绍一种比较容易想到和理解的–逐一枚举法.

- 总体思想:逐一试探法

  对于每一枚硬币,先假设它是轻的,看这样是否符合称量结果.如果符合,问题即解决.如果不符合,就假设它是重的,看是否符合称量结果.把所有硬币都试一遍,一定能找到特殊硬币

  - 定义变量存储称量结果

    `char left[3][7], right[3][7], result[3][7];`

    - 数组下标3代表3次称量
    - 数组下标7代表每次左右至多6枚硬币,多出一个字符位置是为了放'\0',以便使用字符串函数.

- 解法

  - 逐一枚举硬币的代码
  
    ```c++
    for(char c=‘A’; c<=‘L’;c++){
    	if( isLight(c) ){
            cout << c << 
                " is the counterfeit coin and it is light.\n";
            break;
        }
    	else if( isHeavy(c) ){
            cout << c << 
                " is the counterfeit coin and it is heavy.\n";
            break;
        }
    }
    ```
    
  - 判断硬币x是否为重的代码
  
    ```c++
    bool isHeavy(char x)
    { //判断硬币x是否为重的代码
      int i;
      for(i=0; i<3; i++)   // 判断是否与三次称量结果矛盾
         switch( result[i][0] ) {
           case 'u': if( ! inLeft(i,x) )  return false;
                          break;
           case 'e': if(inRight(i,x) || inLeft(i,x))  return false;
                          break;
           case 'd': if(! inRight(i,x))  return false;
                          break;
          }
       return true;
    }
    ```
  
  - 判断硬币是否在第i次称量中的代码
  
    ```c++
    bool inLeft(int i, char x){ 
    // 判断硬币x 是否在第i次称量左侧
    	 return strchr( left[i],x);
    }
    
    bool inRight(int i, char x){
    // 判断硬币x 是否在第i次称量右侧
    	return strchr(right[i],x);
    }
    ```

## 5.2. 例题 熄灯问题

- 问题描述

  有一个由按钮组成的矩阵,其中每行有6个按钮,共5行.每个按钮的位置上有一盏灯.当按下一个按钮后,该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次.即,如果灯原来是点亮的,就会被熄灭;如果灯原来是熄灭的,则会被点亮.

  - 在矩阵角上的按钮改变3盏灯的状态
  - 在矩阵边上的按钮改变4盏灯的状态
  - 其他的按钮改变5盏灯的状态

  

  ![image-20210408131311813](/assets/img/ProgII/image-20210408131311813.png)

  在上图中,左边矩阵中用X标记的按钮表示被按下,右边的矩阵表示灯状态的改变

  ![image-20210408131525375](/assets/img/ProgII/image-20210408131525375.png)

  对矩阵中的每盏灯设置一个初始状态.请你按按钮,直至每一盏等都熄灭.与一盏灯毗邻的多个按钮被按下时,一个操作会抵消另一次操作的结果.在下图中,第2行第3、5列的按钮都被按下,因此第2行、第4列的灯的状态就不改变

  请你写一个程序,确定需要按下哪些按钮,恰好使得所有的灯都熄灭.

- 输入

  第一行是一个正整数N,表示需要解决的案例数.每个案例由5行组成,每一行包括6个数字.这些数字以空格隔开,可以是0或1.0表示灯的初始状态是熄灭的,1表示灯的初始状态是点亮的.

- 输出

  对每个案例,首先输出一行,输出字符串"PUZZLE #m",其中m是该案例的序号.接着按照该案例的输入格式输出5行,其中的1表示需要把对应的按钮按下,0则表示不需要按对应的按钮.每个数字以一个空格隔开.

- 样例

  - 样例输入

    ```
    2 
    0 1 1 0 1 0
    1 0 0 1 1 1 
    0 0 1 0 0 1 
    1 0 0 1 0 1 
    0 1 1 1 0 0 
    0 0 1 0 1 0 
    1 0 1 0 1 1 
    0 0 1 0 1 1 
    1 0 1 1 0 0 
    0 1 0 1 0 0 
    ```

  - 样例输出

    ```
    PUZZLE #1
    1 0 1 0 0 1 
    1 1 0 1 0 1 
    0 0 1 0 1 1 
    1 0 0 1 0 0 
    0 1 0 0 0 0
    PUZZLE #2 
    1 0 0 1 1 1 
    1 1 0 0 0 0 
    0 0 0 1 0 0 
    1 1 0 1 0 1 
    1 0 1 1 0 1 
    ```

- 解题思路

  - Hints
    - 第2次按下同一个按钮时,将抵消第1次按下时所产生的结果.因此,每个按钮最多只需要按下一次.
    - 各个按钮被按下的顺序对最终的结果没有影响
    - 对第1行中每盏点亮的灯,按下第2行对应的按钮,就可以熄灭第1行的全部灯.如此重复下去,可以熄灭第1、2、3、4行的全部灯

  - 第一想法:枚举所有可能的按钮(开关)状态

    对每个状态计算一下最后灯的情况,看是否都熄灭.每个按钮有两种状态(按下或不按下),一共有30个开关,那么状态数是2^30^,太多,会超时.

  - 如何减少枚举的状态数目呢?

    一个基本思路是,如果存在某个局部,一旦这个局部的状态被确定,那么剩余其他部分的状态只能是确定的一种,或者不多的n种,那么就只需枚举这个局部的状态就行了.

  - 本题是否存在这样的“局部”呢?

    经过观察,发现第1行就是这样的一个“局部”.因为第1行的各开关状态确定的情况下,这些开关作用过后,将导致第1行某些灯是亮的,某些灯是灭的.此时要熄灭第1行某个亮着的灯(假设位于第i列),那么唯一的办法就是按下第2行第i列的开关(因为第一行的开关已经用过了,而第3行及其后的开关不会影响到第1行).

    - 因此,为了使第1行的灯全部熄灭,第2行的合理开关状态就是唯一的.
    - 第2行的开关起作用后,为了熄灭第二行的灯,第3行的合理开关状态就也是唯一的,以此类推,最后一行的开关状态也是唯一的.

    总之,只要第1行的状态定下来,比如叫A,那么剩余行的情况就是确定唯一的了.推算出最后一行的开关状态,然后看看最后一行的开关起作用后,最后一行的所有灯是否都熄灭,如果是,那么A就是一个解的状态.如果不是,那么A不是解的状态,第1行换个状态重新试试.

    因此,只需枚举第一行的状态,状态数是2^6^=64

  - 有没有状态数更少的做法?

    枚举第一列,状态数是2^5^=32

- 具体实现

  - 用一个矩阵`anPuzzle[5][6]`表示灯的初始状态

    - `anPuzzle[i][j]=1`:灯(i, j)初始时是点亮的
  - `anPuzzle[i][j]=0`:灯(i, j)初始时是熄灭的
    
  - 用一个矩阵`anSwitch[5][6]`表示要计算的结果

    - `anSwitch[i][j]=1`:需要按下按钮(i, j)
    - `anSwitch[i][j]=1`:不需要按下按钮(i, j)

  - `anSwitch[0]`里放着第1行开关的状态,如何进行枚举呢?

    - 可以使用六重循环:

      ```c
      for( int a0 = 0; a0 < 2; a0 ++ )
          for( int a1 = 0; a1 < 2; a0 ++ ) 
              for( int a2 = 0; a2 < 2; a0 ++ ) 
                  for( int a3 = 0; a3 < 2; a0 ++ ) 
                      for( int a4 = 0; a4 < 2; a0 ++ ) 
                          for( int a5 = 0; a5 < 2; a0 ++ ) {
                              anSwitch[0][0] = a0;    
                              anSwitch[0][1] = a1;
                              anSwitch[0][2] = a2;
                              anSwitch[0][3] = a3;
                              anSwitch[0][4] = a4;
                              anSwitch[0][5] = a5;
                          }  //如果每行开关数目是可变数N那怎么办?  
      ```

    - 适用于一行有N个开关的办法:

      - 一个6位二进制数的所有取值正好是64种,让该数的每一位对应于`anSwitch[0]`里的一个元素(`anSwitch[0][5]`对应最高位,`anSwitch[0][4]`对应次高位……),那么这个二进制数的每个取值正好表示了第一行开关的一种状态.
      - 如果一行有N个开关,那么就用一个N位二进制数
      - 比如,
        - 0的二进制表示形式是`00 0000`,即代表所有开关都不按下
        - 63的二进制表示形式是`11 1111`,即代表所有开关都按下
        - 5的二进制表示形式是`00 0101`,即代表右数第1,3个开关按下

    - 要写一个从二进制数到状态的转换函数:`void SwitchStatus( int n, int * pSwitchLine);`

      该函数将整数n($$0\le n<64$$)的二进制表示形式对应到数组`pSwitchLine`里去(`anSwitch[0][i] `对应第i位)

      ```c
      void SwitchStatus( int n, int * pSwitch)
      {
      	for( i = 0;i < 6 ;i ++ )
      		pSwitch[i] = (n >> i ) & 1;
      }
      ```

    - 要写一个让开关起作用的函数` void ApplySwitch( int* pLights, int* pNextLights, int* pSwitchs); `

      - `pSwitchs`表示一行开关的状态
      - `pLights`表示与开关同一行的灯的状态
      - `pNextLights`表示开关下一行的灯的状态

      本函数根据`pSwitchs`所代表的开关状态,计算这行开关起作用后,`pLights`行和`pNextLights`行的灯的状态

      不考虑开关的上一行的灯,是因为设定`pSwitchs`的值的时候,已经确保会使得上一行的灯变成全灭(或没有上一行)

      ```c
      void ApplySwitch( int * pLights, int * pNextLights, int * pSwitchs)  {
      	for( int i = 0;i < 6; i ++ ) { //依次让每个开关起作用
      		if( pSwitchs[i] ) {
      			//开关左边的灯改变状态
      			if( i > 0 )
      				pLights[i-1] = 1 - pLights[i-1];
      			//开关所在位置的灯改变状态
      			pLights[i] = 1 - pLights[i];
      			//开关右边的灯改变状态
      			if( i < 5) 
      				pLights[i+1] = 1 - pLights[i+1];
      			//开关下边的灯改变状态
      			pNextLights[i] = 1 - pNextLights[i];
      		}
      	}
      }
      ```

- 解法

  ```c++
  #include <memory.h>
  #include <cstring>
  #include <iostream>
  using namespace std;
  
  int T;  
  int anPuzzle[6][6];
  int anOriPuzzle[6][6];
  int anSwitch[6][6]; //开关状态
  int i,j;
  
  void SwitchStatus( int n, int * pSwitch)
  {
  	for( i = 0;i < 6 ;i ++ )
  		pSwitch[i] = (n >> i ) & 1;
  }
  
  void ApplySwitch( int * pLights, int * pNextLights, int * pSwitchs)  {
  	for( int i = 0;i < 6; i ++ ) { //依次让每个开关起作用
  		if( pSwitchs[i] ) {
  			//开关左边的灯改变状态
  			if( i > 0 )
  				pLights[i-1] = 1 - pLights[i-1];
  			//开关所在位置的灯改变状态
  			pLights[i] = 1 - pLights[i];
  			//开关右边的灯改变状态
  			if( i < 5) 
  				pLights[i+1] = 1 - pLights[i+1];
  			//开关下边的灯改变状态
  			pNextLights[i] = 1 - pNextLights[i];
  		}
  	}
  }
  
  void OutputResult(int t) //输出结果
  {
  	cout << "PUZZLE #" << t << endl;
  	for( int i = 0;i < 5; i ++ ) {
  		for( int j = 0; j < 6; j ++ ) {
  			cout << anSwitch[i][j];
  			if( j < 5 ) cout << " ";
  		}
  		cout << endl;
  	}
  }
  
  int main()   {
  	cin >> T;
  	for( int t = 0; t < T; t ++ ) {
  		for( i = 0;i < 5; i ++ )
  			for(  j = 0; j < 6; j ++ ) 
  				cin >> anOriPuzzle[i][j];
  		for( int n = 0; n < 64; n ++ ) { //遍历首行开关的64种状态
  			memcpy( anPuzzle,anOriPuzzle,sizeof(anPuzzle));
  			//算出n所代表的开关状态,放到anSwitch[0]
  			SwitchStatus( n, anSwitch[0]);
              //下面逐行让开关起作用,并算出下一行开关应该是什么状态,再让它们起作用……
  			for( int k = 0; k < 5; k ++ ) {
  				//算出第k行开关起作用后的结果
  				ApplySwitch( anPuzzle[k],
  					anPuzzle[k+1],anSwitch[k]);\
                      //第k+1行的开关状态应和第k行的灯状态一致
  				memcpy( anSwitch[k+1], anPuzzle[k], sizeof(anPuzzle[k]));
  			}
              bool bOk = true; //记录最后一行灯是不是全灭
  			//看最后一行灯是不是全灭
  			for(  k = 0; k < 6; k ++ ) {
  				if( anPuzzle[4][k] ) {
  					bOk = false;
  					break;
  				}
  			}
  			if( bOk )  {
  				OutputResult(t+1); //输出解
  				break; //找到解,就不用再试下一种状态了
  			}
  		} 
  	}
  }
  ```

## 5.3. 讨厌的青蛙

- 问题描述

  问题描述:在韩国,有一种小的青蛙.每到晚上,这种青蛙会跳越稻田,从而踩踏稻子.农民在早上看到被踩踏的稻子,希望找到造成最大损害的那只青蛙经过的路径.每只青蛙总是沿着一条直线跳越稻田,而且*每次跳跃的距离都相同*.

  ![image-20210408225359631](/assets/img/ProgII/image-20210408225359631.png)

  - 如下图所示,稻田里的稻子组成一个栅格,每棵稻子位于一个格点上.而青蛙总是从稻田的一侧跳进稻田,然后沿着某条直线穿越稻田,从另一侧跳出去

    ![image-20210408225424476](/assets/img/ProgII/image-20210408225424476.png)

  - 如下图所示,可能会有多只青蛙从稻田穿越.青蛙的每一跳都恰好踩在一棵水稻上,将这棵水稻拍倒.有些水稻可能被多只青蛙踩踏.当然,农民所见到的是图4中的情形,并看不到图3中的直线,也见不到别人家田里被踩踏的水稻.

    ![image-20210408225509405](/assets/img/ProgII/image-20210408225509405.png)

  - 根据图4,农民能够构造出青蛙穿越稻田时的行走路径,并且只关心那些在穿越稻田时至少踩踏了3棵水稻的青蛙.因此,每条青蛙行走路径上至少包括3棵被踩踏的水稻.而在一条青蛙行走路径的直线上,也可能会有些被踩踏的水稻不属于该行走路径

    <img src="/assets/img/ProgII/image-20210408225751481.png" alt="image-20210408225751481" style="zoom:50%;" />

    - <font color = red>①</font>不是一条行走路径:只有两棵被踩踏的水稻
    - <font color = green>②</font>是一条行走路径,但不包括(2,6)上的水稻
    - <font color = blue>③</font>不是一条行走路径:虽然有3棵被踩踏的水稻,但这三棵水稻之间的距离间隔不相等

  - 请你写一个程序,确定:在各条青蛙行走路径中,踩踏水稻最多的那一条上,有多少颗水稻被踩踏.例如,图4的答案是7,因为第6行上全部水稻恰好构成一条青蛙行走路径

- 输入

  从标准输入设备上读入数据.第一行上两个整数R、C,分别表示稻田中水稻的行数和列数,$$1\le R,C\le5000$$.第二行是一个整数N,表示被踩踏的水稻数量,$$3\le N\le 5000$$.在剩下的N行中,每行有两个整数,分别是一颗被踩踏水稻的行号(1\~R)和列号(1\~C),两个整数用一个空格隔开.而且,每棵被踩踏水稻只被列出一次.

- 输出

  从标准输出设备上输出一个整数.如果在稻田中存在青蛙行走路径,则输出包含最多水稻的青蛙行走路径中的水稻数量,否则输出0.

- 样例

  - 样例输入

    ```
    6 7
    1 4 
    2 1 
    6 6 
    4 2 
    2 5 
    2 6 
    2 7 
    3 4 
    6 1 
    6 2 
    2 3 
    6 3 
    6 4 
    6 5 
    6 7 
    ```

  - 样例输出

    ```
    7
    ```

- 解题思路-枚举

  枚举什么?	枚举路径上的开始两点

  - 每条青蛙行走路径中至少有3棵水稻
  - 假设一只青蛙进入稻田后踩踏的前两棵水稻分别是(X~1~,Y~1~),(X~2~,Y~2~).那么:
    - 青蛙每一跳在X方向上的步长dX=X~2~-X~1~在Y方向上的步长dY=Y~2~-Y~1~ 
    - (X~1~-dX,Y~1~-dY)需要落在稻田之外
    - 当青蛙踩在水稻(X,Y)上时,下一跳踩踏的水稻是(X+dX,Y+dY)
    - 将路径上的最后一棵水稻记作(X~K~,Y~K~),(X~K~+d~X~,Y~K~+dY)需要落在稻田之外

- 解题思路-猜测一条路径

  - 猜测的办法需要保证:每条可能的路径都能够被猜测到

    - 从输入的水稻中任取两棵,作为一只青蛙进入稻田后踩踏的前两棵水稻,看能否形成一条穿越稻田的行走路径

  - 猜测的过程需要尽快排除错误的答案:猜测(X~1~,Y~1~),(X~2~,Y~2~)就是所要寻找的行走路径上的前两棵水稻.当下列条件之一满足时,这个猜测就不成立

    - 青蛙不能经过一跳从稻田外跳到(X~1~,Y~1~)上
    - 按照(X~1~,Y~1~),(X~2~,Y~2~)确定的步长,从(X~1~,Y~1~)出发,青蛙最多经过`MAXSTEPS-1`步,就会跳到稻田之外.`MAXSTEPS`是当前已经找到的最好答案

  - 选择合适的数据结构:采用的数据结构需要与问题描述中的概念对应

    - 方案1:

      ```c
      struct {
            int x, y;
      } plants[5000];
      ```

    - 方案2:

      ```c
      int plantsRow[5000], plantsCol[5000];
      ```

    显然方案1更符合问题本身的描述

  - 设计的算法要简洁

    - 尽量使用C提供的函数完成计算的任务:猜测一条行走路径时,需要从当前位置(X,Y)出发上时,看看(X+dX,Y+dY)位置的水稻水稻是否被踩踏

      - 方案1:自己写一段代码,看看(X+dX,Y+dY)是否在数组`plants`中;
      - 方案2:先用`qsort()`对`plants`中的元素排序,然后用`bsearch()`从中查找元素(X+dX,Y+dY)

      显然基于方案2设计的算法更简洁、更容易实现、更不容易出错误

    - 通常,所选用的数据结构对算法的设计有很大影响

    - 注意,一个有n个元素的数组,每次取两个元素,遍历所有取法的代码写法:

      ```c
      for( int i = 0; i < n – 1 )
          for( int j = i + 1; j < n; j ++ ) {
              a[i] = …;
              a[j] = …;
          }
      ```

    - 二分查找函数:

      ```c
      void *bsearch(const void *key, const void *base, size_t nelem, size_t width, int (_USERENTRY *fcmp)(const void *, const void *)); 
      //查到返回地址,查不到返回空指针
      ```

- 参考程序

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  int r, c, n;
  struct PLANT {
  	int x, y;
  };
  PLANT plants[5001];
  PLANT plant;
  int myCompare( const void *ele1, const void *ele2 );
  int searchPath(PLANT secPlant, int dX, int dY) ;
  int main(void)
  {	
  	int i,j, dX, dY, pX, pY, steps, max = 2;
  	scanf("%d%d", &r, &c);
  	scanf("%d", &n);
  	for (i = 0; i < n; i++)
  		scanf("%d%d", &plants[i].x, &plants[i].y);
  	qsort(plants, n, sizeof(PLANT), myCompare);
  	for (i = 0; i < n - 2; i++)  //plants[i]是第一个点
  		for ( j = i + 1; j < n -1 ; j++) {  // plants[j]是第二个点
  		    dX = plants[ j ].x - plants[i].x; 
  		    dY = plants[ j ].y - plants[i].y;
  		    pX = plants[ i ].x - dX; 
  		    pY = plants[ i ].y - dY;
  		    if (pX <= r && pX >= 1 && pY <= c && pY >= 1)
  			continue; //第一点的前一点在稻田里,说明本次选的第
   				  //二点导致的步长不合理,取下一个点作为第二点
  		    if (plants[ i ].x + (max - 1) * dX > r)
  			break;    //x方向过早越界了.说明本次选的第二点不成立.
  			//如果换下一个点作为第二点,x方向步长只会更大,更不成立,所以应该
  			//认为本次选的第一点都是不成立的,那么取下一个点作为第一点再试
  		    pY = plants[ i ].y + (max - 1) * dY;
  		    if ( pY > c || pY < 1)
  			continue; //y方向过早越界了,应换一个点作为第二点再试
  		    steps = searchPath(plants[ j ],dX,dY); //看看从这两点出发,一共
  							//能走几步
  		    if (steps > max)  	max = steps;
  		}
      if ( max == 2 ) max = 0;
  	printf("%d\n", max);  
  }
  int myCompare( const void *ele1, const void *ele2 )
  {
  	PLANT *p1, *p2;
  	p1 = (PLANT*) ele1;
  	p2 = (PLANT*) ele2;
  	if ( p1->x == p2->x ) return(p1->y - p2->y);
  	return ( p1->x - p2->x );
  }
  //判断从 secPlant点开始,步长为dx,dy,那么最多能走几步
  int searchPath(PLANT secPlant, int dX, int dY)
  {
  	PLANT plant;
  	int steps;
  
  	plant.x = secPlant.x + dX;
  	plant.y = secPlant.y + dY;
  	steps = 2;
  	while (plant.x <= r && plant.x >= 1 && plant.y <= c && plant.y >= 1) {
  		if (!bsearch(&plant, plants, n, sizeof(PLANT), myCompare)) 	{ 
              //每一步都必须踩倒水稻才算合理,否则这就不是一条行走路径
  			steps = 0;
  			break;
  		}
  		plant.x += dX; 
  		plant.y += dY;
  		steps++;
  	}
  	return(steps);
  }
  ```

---



# 6. 递归

## 6.1. 引言:什么是递归?

**程序调用自身的编程技巧称为递归(recursion).**

### 6.1.1. 例1

- 阶乘的*递推*定义: $$0!=1\quad1!=0!\times1=1\quad2!=1!\times2=2$$
- 阶乘的*递归*定义: $$n!=(n-1)!\times n,0!=1$$

如何用C语言函数求n的阶乘?

- 求阶乘的*递推*程序

  ```c
  int fact (int n)
  {
      if (n<0) return -1;
      fact=1; i=1; 
      while (i<=n)
      {
          fact *= i; i++;
      }
  }
  ```

- 求阶乘的*递归*程序

  ```c
  int factorial(int n)
  {
     if (n < 0)	return -1;
     if (n == 0)	return 1;
     else         return  n * factorial(n - 1);
  }
  
  int main()
  {  
      cout<< factorial(4)<<endl;
  }
  ```

### 6.1.2. 递归

- 一个过程或[函数](http://baike.baidu.com/view/15061.htm)在其定义或说明中又直接(或间接)调用自身的一种方法.它通常把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.

- 一般来说,递归需要有**边界条件**、**递归策略**和**递归返回段**.当边界条件不满足时,递归往边界条件前进;当边界条件满足时,递归返回.

  ```c
  int  fact (int n)
  {
      if (n==0) return 1;    // 递归边界条件和递归返回
      return n*fact(n-1);    // 递归策略
  }
  ```

- 阶乘函数的执行过程

  <img src="/assets/img/ProgII/image-20210408233155271.png" alt="image-20210408233155271" style="zoom:50%;" />

## 6.2. 递归函数求解问题的三个关键点

1. 找出递归的求解策略;
2. 找到递归的终止条件;
3. 先设计出递归函数的原型(prototype),然后在函数体中进行递归调用.

## 6.3.递归的应用

1. 数据的定义是按递归定义的.

   例如:Fibonacci函数,阶乘函数等.

2. 问题解法按递归算法实现.

   这类问题虽则本身没有明显的递归结构,但用递归求解比迭代求解更简单,例如:汉诺塔（Hanoi）问题,八皇后问题.

3. 数据的结构形式是按递归定义的.

   如二叉树、广义表等,由于结构本身固有的递归特性,则它们的操作可递归地描述(《数据结构》、《算法基础》等课程涉及)

### 汉诺塔问题

<img src="/assets/img/ProgII/image-20210409080541013.png" alt="image-20210409080541013" style="zoom:67%;" />

- 规则描述

  以C柱为中转站,将盘从A柱移动到B柱上,一次只能移动一个盘,而且大盘不能压在小盘上面.

- 求解任务

  要求写程序描述移动的过程,<u>要求移动次数最少</u>.

- 问题1:如何描述移动的过程?

  - 对于这种典型的非数值计算的问题,可以用一个字符串来描述移动"指令"

    例如:`A->C`表示把A柱最上面的一块盘移动到C柱最上面

  - 3块盘的汉诺塔问题移动过程:

    - 样例输入:

      ```
      3
      ```

    - 样例输出:

      ```
      A->B
      A->C
      B->C
      A->B
      C->A
      C->B
      A->B
      ```

- 问题2:如何应用递归求解?

![image-20210409081138592](Programming II.assets/image-20210409081138592.png)

![image-20210409081556217](Programming II.assets\image-20210409081556217.png)
  

<img src="Programming II.assets/image-20210409081138592.png" alt="image-20210409081138592"  />

<img src="Programming II.assets/image-20210409081556217.png" alt="image-20210409081556217" style="zoom:110%;" />

<img src="/assets/img/ProgII/image-20210409081711862.png" alt="image-20210409081711862" style="zoom:110%;"/>

- n块盘的汉诺塔问题的**递归策略**:

  若想将n个盘子从A柱移动到B柱,用C柱做中转,可以分以下3步实现:

  1. 先将A上的n-1个盘,以B为中转,从A柱移到C柱;
  2. 将A中最大的一个盘子从A移动到B;
  3. 将C柱上的n-1个盘子.以A为中转,移动到B柱.

- 递归的**结束条件**:

  当`n==1`时,`cout<<"A->B"<<endl;`

- 递归函数的**原型**:

  - 函数名:`hanoi`无疑;
  - 函数参数:涉及到了`int n; char A,B,C;`先罗列上去(多退少补);
  - 返回值:不需要,`void`

  ```
  //将n个盘子从a柱移动到b柱,用c柱做中转
  void Hanoi(int n,char a,char b,char c);
  ```

- 汉诺塔问题递归函数:

  ```c++
  #include <iostream>
  using namespace std;
  //将n个盘子从a柱移动到b柱,用c柱做中转
  void Hanoi(int n,char a,char b,char c)
  {
  	if( n == 1 ) {
  		cout << a << "->" << b << endl;
  		return ;
  	}
  	//先将n-1个盘子,以b为中转,从a柱移动到c柱,
  	Hanoi( n-1,a,c,b);
  	//将一个盘子从a移动到b
  	cout << a << "->" << b << endl;
  	//将c柱上的n-1个盘子,以a为中转,移动到b柱
  	Hanoi( n-1,c,b,a);
  }
  int main()   {
  	int N;
  	cout << "Please input disc number: " << endl;
  	cin >> N;
  	cout << "The solution is:" << endl;
  	Hanoi( N,'A','B','C');
  }
  ```

---

### 递归的优缺点:

- 运用递归策略只需**少量的程序**就可描述出解题过程所需要的多次重复计算,大大地减少了程序的代码量.
- 递归方法解题运行效率较低(例如用递推求n!).因此,应该尽量避免使用递归,除非没有更好的算法.
- 在递归调用的过程当中系统为每一层调用的返回点、局部变量等开辟了栈来存储(又称活动记录栈).递归次数过多容易造成栈溢出等.

:warning:由于函数的局部变量是存在栈上的,如果有体积大的局部变量,比如数组,而递归层次又可能很深的情况下,也许会导致栈溢出,因此可以考虑使用全局数组或动态分配数组.

## 6.4. 例题 放苹果

a个苹果,d个盘子,问多少种不同放法,盘子和苹果都是没有编号的,即1,2,3和3,2,1算是同一种放法

- 算法

  设$$f(a,d)$$为a个苹果,d个盘子的放法数目,则先对a作讨论

  - 如果$$d>a$$,必定至少有d-a个盘子是空的,去掉这些空盘子对摆放苹果方法数目不产生影响;即

    ```c
    if (d > a)
        f(a, d) = f(a, a);
    ```

  - 当$$d\le a$$时,不同的放法可以分成两类:

    1. 有盘子空着
    
       假定该情况下的放法数目为$$g(a,d)$$
    
    2. 所有盘子都有苹果,即没有盘子空着
    
       假定该情况下的放法数目为$$k(a,d)$$
    
    则显然:$$f(a,d)=g(a,d)+k(a,d)$$
    
    然而:$$g(a,d) = f(a,d-1)\qquad k(a,d)=f(a-d,d)$$
    
    因此:$$f(a,d)=f(a,d-1)+f(a-d,d)$$

  递推公式:

  $$
  f(a,d)=\left\{
    \begin{align}
    &f(a,a),d>a
    \\
    &f(a,d-1)+f(a-d,d),d\ge a
    \end{align}
    \right.
  $$
  即:

  ```c
  if(d > a) 
  	f(a, d) = f(a, a);
  else
  	f(a, d) = f(a, d - 1) + f(a - d, d);
  
  ```

  *出口条件是什么呢？*

  出口条件说明:
  1. 当$$d=1$$时,所有苹果都必须放在一个盘子里,所以返回1;
  2. 当没有苹果可放时,所有盘子都是空的,这当然是一种放法,所以也返回1;

  递归的两条路:

  1. 第一条会逐渐减少,终会到达出口`d==1`; 
  2. 第二条a会逐渐减少,因为d>a时,我们会`return f(a,a);`,所以终会到达出口`a==0`．

## 6.5. n皇后问题

### 6.5.1. 八皇后问题

- 问题描述

  会下国际象棋的人都很清楚:皇后可以在横、竖、斜线上不限步数地吃掉其他棋子.如何将8个皇后放在棋盘上(有8 * 8个方格),使它们谁也不能被吃掉!这就是著名的八皇后问题.

  对于某个满足要求的8皇后的摆放方法,定义一个皇后串a与之对应,即a=b~1~b~2~...b~8~,其中b~i~为相应摆法中第i行皇后所处的列数.

  已经知道8皇后问题一共有92组解(即92个不同的皇后串).
  给出一个数b,要求输出第b个串.串的比较是这样的:皇后串x置于皇后串y之前,当且仅当将x视为整数时比y小.

- 输入

  第1行是测试数据的组数n,后面跟着n行输入.每组测试数据占1行,包括一个正整数b($$1 \le b \le 92$$)

- 输出

  输出有n行,每行输出对应一个输入.输出应是一个正整数,是对应于b的皇后串.

- 样例

  - 样例输入

    ```
    2
    1
    92
    ```

  - 样例输出

    ```
    15863724
    84136275
    ```

八皇后问题可用八重循环解决.但是N皇后问题呢?

**:warning:递归可以用来实现任意多重循环**

<u>如果有多个变量,每个变量有各自的取值范围,要覆盖这些变量值的全部组合,可以用递归实现</u>

此题**没有什么直接的递推关系**,写递归就是为了起到多重循环的作用

### 6.5.2. n皇后问题

主要思想:回溯

- 按选优条件向前搜索,以达到目标.
  - 当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择.
- 用数组模拟棋盘,从第一行开始,依次选择位置.
  - 如果当前位置满足条件,则向下选位置.
  - 如果不满足条件,那么当前位置后移一位.

处理行,列,对角线:

- 行作为循环变量(递归函数参数)

- 使用`q[n]`存储皇后位置(`q[i]`表示第i行第`q[i]`列有皇后)

- 使用`col[n]`存储列上是否有皇后(`col[i]==1`说明第i列上已经存在皇后)

- <img src="/assets/img/ProgII/image-20210415230712699.png" alt="image-20210415230712699" style="zoom:20%;" align = "left" />使用`md[2*n-1]`,`sd[2*n-1]`分别存储主次对角线上是否有皇后(有为`1`,无为`0`)

  其中主对角线数=j-i+n-1,副对角线数=i+j















- 算法

  ```c
  void Queen(int i, int n){
      for(int j = 0; j < n; j ++){
          if(第i行第j列没有攻击){//!col[j] && !md[j - i + n - 1] && !sd[i + j]
              在第i行第j列安放皇后;
              if(i == n - 1) 输出一个布局;
              else Queen(i + 1, n);
              撤销第i行第j列的皇后;
          }
      }
  }
  ```

## 6.6. 例题 逆波兰表达式

- 问题描述

  逆波兰表达式是一种把运算符前置的算术表达式,例如普通的表达式`2 + 3`的逆波兰表示法为`+ 2 3`.

  逆波兰表达式的优点是运算符之间不必有优先级关系,也不必用括号改变运算次序,例如`(2 + 3) * 4`的逆波兰表示法为`* + 2 3 4`,本题求解逆波兰表达式的值,其中运算符包括`+`,`-`,`*`,`/`四个.

- 输入

  输入为一行,其中运算符和运算数之间都用空格分隔,运算数是浮点数.

- 输出

  输出为一行,表达式的值.

- 样例

  - 样例输入

    ```
    * + 11.0 12.0 + 24.0 35.0
    ```

  - 样例输出

    ```
    1357.0000000
    ```

- 解题思路

  这个问题看上去有些复杂,如果只是简单地模拟计算步骤不太容易想清楚,但是如果用递归的思想就非常容易想清楚.让我们根据逆波兰表达式的定义进行递归求解.

  在递归函数中,针对当前的输入,有五种情况:

  1. 输入是常数,则表达式的值就是这个常数;

  2. 输入是''+',则表达式的值是再继续读入两个表达式并计算出它们的值,然后将它们的值相加;

  3. 输入是'-';

  4. 输入是'\*';

  5. 输入是'/';

     后几种情况与2）相同,只是计算从'+'变成'-','\*','/'.

- 解法

  ```c
  #include <stdio.h>
  #include <math.h>
  double exp() {
      char a[10];
      scanf("%s", a);
      switch(a[0]){
          case '+': return exp() + exp();
          case '-': return exp() - exp();
          case '*': return exp() * exp();
          case '/': return exp() / exp();
          default:  return atof(a); //字符串转浮点数
      }
  }
  int main(){
      double ans;
      ans = exp();
      printf("%f", ans);
  }
  ```

## 6.7. 例题 黑瓷砖上行走

- 问题描述

  有一间长方形的房子,地上铺了红色、黑色两种颜色的正方形瓷砖.你站在其中一块黑色的瓷砖上,只能向相邻的黑色瓷砖移动.请写一个程序,计算你总共能够到达多少块黑色的瓷砖.

  ![image-20210416085338456](/assets/img/ProgII/image-20210416085338456.png)

- 输入

  包括多个数据集合.

  每个数据集合的第一行是两个整数W和H,分别表示x方向和y方向瓷砖的数量.

  W和H都不超过20.

  在接下来的H行中,每行包括W个字符.

  每个字符表示一块瓷砖的颜色,规则如下:

  - '.':黑色的瓷砖
  - '#':红色的瓷砖
  - '@':黑色的瓷砖,并且你站在这块瓷砖上.该字符在每个数据集合中唯一出现一次

  当在一行中读入的是两个零时,表示输入结束.

- 输出

  对每个数据集合,分别输出一行,显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)

- 样例

  - 样例输入
  
    ```
    6 9 
    ....#. 
    .....# 
    ...... 
    ...... 
    ...... 
    ...... 
    ...... 
    #@...# 
    .#..#. 
    0 0
    ```
  
  - 样例输出
  
    ```
    45
    ```
  
- 算法

  设$$ f(x,y)$$为从点$$ (x,y)$$出发能够走过的黑瓷砖总数,而且$$ (x,y)$$是黑瓷砖

  $$
  f(x,y) = 1+f(x-1,y)+f(x+1,y) +f(x,y-1)+f(x,y+1)
  $$

  这里需要注意,凡是走过的瓷砖不能够被重复走过.

递归终止条件:如果$$(x,y)$$是红瓷砖,则`return 0;`

- 程序:

  ```c++
  #include <iostream> 
  using namespace std;
  const int  MAX 22 
  //方块四周加红色块,去掉边界判断,
  //使得递归统一终止于红色块
  char rect[MAX][MAX]; 
  //返回从某点出发能走到的格子数
  int walkFrom(int currentRow, int currentCol); 
  int main() { 
  	int col,row; 
  	while(cin >> col >> row , col!=0 && row !=0){ 
  	int i,j,startRow,startCol; 
  	for(i=0;i<MAX;i++)　
  		for(j=0;j<MAX;j++) 　
  			rect[i][j]='#'; 
  	for(i=1;i<=row;i++) 　
  		for(j=1;j<=col;j++){　
              cin >> rect[i][j]; 
              if(rect[i][j] == '@'){ 
                  startRow = i; 
                  startCol = j; 
                  rect[i][j]=‘.’; 　//人站立处是黑砖
              } 
  		} 
  		cout << walkFrom(startRow,startCol) << endl;
  	}//while 
  } 
  int walkFrom(int currentRow, int currentCol) { 
  	if(rect[currentRow][currentCol] == '#')
  		return 0; 
  	else 
  		//本瓷砖算走过,以后不能再走了
  		rect[currentRow][currentCol] = '#'; 
      
  	return 1+walkFrom(currentRow+1,currentCol)
  			+walkFrom(currentRow-1,currentCol)
  			+walkFrom(currentRow,currentCol+1)
  			+walkFrom(currentRow,currentCol-1) ; 
  } 
  ```


---



# 7. 搜索

搜索:高级枚举

- 有顺序有策略地枚举空间中的节点,寻找问题的解

## 7.1. 例题 八数码问题

  <img src="/assets/img/ProgII/image-20210428211955882.png" alt="image-20210428211955882" style="zoom:67%;" />

- 状态空间:

  <img src="/assets/img/ProgII/image-20210428212102180.png" alt="image-20210428212102180" style="zoom:150%;" />

### 7.1.1. 广度优先搜索

- 优先扩展浅层结点,逐渐深入

  ![image-20210428212121426](/assets/img/ProgII/image-20210428212121426.png)

- 用队列保存待扩展的结点,从队首队取出结点,扩展出的新结点放入队尾,直到找到目标结点(问题的解)

- 广度优先搜索的代码框架:

  ```
  BFS()
  {
  	初始化队列
  	while(队列不为空且未找到目标结点)
  	{
  		取队首结点扩展,并将扩展出的结点放入队尾
  		必要时要记住每个结点的父结点
  	}
  }
  
  ```

### 7.1.2. 深度优先搜索

- 优先深入历遍靠前的结点

  ![image-20210428212330872](/assets/img/ProgII/image-20210428212330872.png)

- 实现:

  - 可以用栈实现,在栈中保存从起始结点到当前结点的路径上的所有结点
  - 一般用递归实现

- 框架

  - 深度优先搜索的非递归框架

    ```
    DFS()
    {
    	初始化栈
    	while(栈不为空 && 未找到目标结点)
    	{
    		取栈顶结点扩展,扩展出的结点放回栈顶
    	}
    	......
    }
    ```

  - 深度优先搜索的递归框架

    - 在深度优先搜索中,状态空间的图结构并不一定需要显式的存下来.

      ```
      type node;
      void DFS(int depth){
      	for(node的每一个可行变化){
      		改变node
      		DFS(depth + 1)
      		恢复node
      	}
      }
      ```

      此种做法需要一个全局数组`array`来存放每个走过的`node`,`array[depth]`就是进入DFS函数时需要扩展的节点

- 判重

  - 新扩展出的结点如果和以前扩展出的结点相同,则则个新节点就不必再考虑

  - 如何判重?

    ![image-20210428212717125](/assets/img/ProgII/image-20210428212717125.png)

    - 需要考虑的问题:

      - 状态数目巨大,如何存储?
      - 怎样才能较快的找到重复结点?

    - 合理编码,减小存储代价

      - 不同的编码方式所需要的存储空间会有较大差别

      1. 方案一:每个节点对应于一个九进制数,则*4个字节就能表示一个节点*.
         - 判重需要一个标志位序列,每个状态对应于标志位序列中的1位,标志位为0表示该状态尚未扩展,为1则说明已经扩展过了.
         - 标志位序列可以用字符数组存放.数组的每个元素存放8个状态的标志位.位序列最多需要9^9^位,因此存放位序列的数组需要$$\displaystyle\left(\frac {9^9}{8} + 1\right)个字节=\color{red}{48427562字节}$$
         - 如果某个状态对应于一个9进制数a,则其标志位就是标志位序列中的第a位(其所属的数组元素下标是a/8)
         - 此方案需要编写字符串形式的9进制数到其整型值的互相转换函数.
      2. 方案二:为结点编号
         - 把每个结点都看一个排列,以此排列在全部排列中的位置作为其编号
         - 排列总数:$$9!=362880$$
         - 只需要一个整数(4字节)即可存下一个结点
         - 判重用的标志数组只需要362880字节即可.

      方案2比方案1*省空间*.

      方案2需要编写给定排列求序号和给定序号求排列的函数,*这些函数的执行速度慢于字符串形式的9进制数到其整型值的互相转换函数*(方案1).

      - 时间与空间的权衡

        - 对于状态数较小的问题,可以用最直接的方式编码以空间换时间
        - 对于状态数太大的问题,需要利用好的编码方法以时间换空间

        <u>具体问题具体分析</u>

- 输入:一行,共9个由空格分隔开的字符,其中8个分别为数字1-8,另一个为字母x,代表空格,每三个字符为八数码中的一行.

- 输出:一个移动序列,使得移动后结果变成

  ```
  1 2 3
  4 5 6
  7 8
  ```

  移动序列中

  - u-表示使空格上移
  - d-表示使空格下移
  - r-表示使空格右移
  - l-表示使空格左移

- 样例

  - 样例输入

    ```
    2 3 4 1 5 x 7 6 8
    ```

    样例代表:

    ```
    2 3 4
    1 5
    7 6 8 
    ```

  - 样例输出

    ```
    ullddrurdllurdruldr
    ```

- 用广搜解决八数码问题

  - 例解

    ```c++
    //本程序在ai上会超内存,在acm上能过
    
    #include <iostream>
    using namespace std;
    int nGoalStatus;  //目标状态
    unsigned char szFlag[48427562]; //节点是否扩展的标记
    char szResult[1000000];
    char szMoves[1000000]; //移动步骤  
    int anFather[1000000]; //父节点指针 
    int MyQueue[1000000];  //状态队列
    int nQHead; 
    int nQTail;
    char sz4Moves[] = "udrl";//四种动作
    int NineToTen( char * s )
    //九进制字符串转十进制
    {
    	int nResult = 0;
    	for( int i = 0; s[i]; i ++ ) {
    		nResult *= 9;
    		nResult += s[i] - '0';
    	}
    	return nResult;
    }
    int GetBit( unsigned char c,int n)  {
    	return ( c >> n ) & 1;
    }
    void SetBit( unsigned char & c, int n,int v)  {
    	if( v )
    		c |= (1 << n);
    	else
    		c &= ~(1 << n);
    
    }
    int TenToNine( int n, char * s)
    //十进制数转九进制字符串.可能有前导0
    //返回0的位置
    {
    	int nZeroPos;
    	int nBase = 1;
    	int j = 0;
    	while( nBase <= n)
    		nBase *= 9;
    	nBase /= 9;
    	do {
    		s[j] = n/nBase + '0';
    		if( s[j] == '0' )
    			nZeroPos = j;
    		j ++;
    		n %= nBase;
    		nBase /= 9;
    	}while( nBase >= 1 );
    	s[j] = 0;
    	//判是否要加前导0
    	if( j < 9 ) {
    		for( int i = j + 1; i > 0; i --)
    			s[i] = s[i-1];
    		s[0] = '0';
    		return 0;
    	}
    	return nZeroPos;
    }
    int NewStatus( int nStatus, char cMove)
    //求从nStatus经过 cMove 移动后得到的新状态
    //若移动不可行则返回-1
    { 	char szTmp[20];
    	int nZeroPos = TenToNine(nStatus,szTmp);
    	switch( cMove) {
    		case 'u':
    			if( nZeroPos - 3 < 0 )
    				return -1;
    			else {
    				szTmp[nZeroPos] = szTmp[nZeroPos - 3];
    				szTmp[nZeroPos - 3] = '0';
    			}
    			break;
    		case 'd':
    			if( nZeroPos + 3 > 8 )
    				return -1;
    			else {
    				szTmp[nZeroPos] = szTmp[nZeroPos + 3];
    				szTmp[nZeroPos + 3] = '0';
    			}
    			break;
    
    		case 'l':
    			if( nZeroPos % 3 == 0)
    				return -1;
    			else {
    				szTmp[nZeroPos] = szTmp[nZeroPos -1];
    				szTmp[nZeroPos -1 ] = '0';
    			}
    			break;
    		case 'r':
    			if( nZeroPos % 3 == 2)
    				return -1;
    			else {
    				szTmp[nZeroPos] = szTmp[nZeroPos + 1];
    				szTmp[nZeroPos + 1 ] = '0';
    			}
    			break;
    	}
    	return NineToTen(szTmp);
    }
    bool Bfs(int nStatus)
    {
    	int nNewStatus;
    	nQHead = 0;
    	nQTail = 1;
    	MyQueue[nQHead] = nStatus;
    	while ( nQHead != nQTail) { //队列不为空
    		nStatus = MyQueue[nQHead];
    		if( nStatus == nGoalStatus ) {//找到目标状态 
    			return true;
    		}
    		for( int i = 0;i < 4;i ++ ) { //尝试4种移动
    			nNewStatus = NewStatus(nStatus,sz4Moves[i]);	
    			if( nNewStatus == -1 ) 
    				continue; //不可移,试下一种移法
    			int nByteNo = nNewStatus / 8;
    			int nBitNo = nNewStatus % 8;
    			if( GetBit( szFlag[nByteNo],nBitNo)) //如果扩展标记已经存在,则不能入队
    				continue; 
    			//设上已扩展标记
    			SetBit( szFlag[nByteNo],nBitNo,1); 	
    			//新节点入队列 
    			MyQueue[nQTail] = nNewStatus; 				
                anFather[nQTail] = nQHead; //记录父节点
    			//记录本节点是由父节点经什么动作而来
                szMoves[nQTail] = sz4Moves[i];
                nQTail ++;
    		}
    		nQHead ++; 
    	}
    	return false;	
    }
    int main()
    {
    	nGoalStatus = NineToTen("123456780");
    	memset(szFlag,0,sizeof(szFlag));
    	char szLine[50];
    	char szLine2[20];
    	cin.getline(szLine,48);
    	int i,j;
    	//将输入的原始字符串变为九进制字符串
    	for( i = 0, j = 0; szLine[i]; i ++ ) {
    		if( szLine[i] != ' ' ) {
    			if( szLine[i] == 'x' )
    				szLine2[j++] = '0';
    			else
    				szLine2[j++] = szLine[i];
    		}
    	}
    	szLine2[j] = 0;
    	if( Bfs(NineToTen(szLine2))) {
    		int nMoves = 0;
    		int nPos = nQHead;
    		do { 
    			szResult[nMoves++] = szMoves[nPos];
    			nPos = anFather[nPos]; 
    		} while( nPos);
    		for( int i = nMoves -1; i >= 0; i -- ) {
    			cout << szResult[i];
    		}
    	}
    	else
    		cout << "unsolvable" << endl;
    	 
    }
    ```

## 7.2. 广搜与深搜的比较

- 广搜一般用于状态表示比较简单,求最优策略的问题
  - 需要保存所有扩展出的状态,占用的空间大
  - 每次扩展出结点时所走过的路径均是最短路
- 深搜几乎可以用于任何问题
  - 只需要保存从起始状态到当前状态路径上的结点
- 根据题目要求凭借自己的经验和对两个搜索的熟练程度做出选择
- 影响搜索效率的因素:
  - 搜索对象(枚举什么)
  - 搜索顺序(先枚举什么,后枚举什么)
  - 剪枝(及早判断出不符合要求的情况)

---



# 8. 动态规划

## 8.1. 引言:树形递归存在冗余计算

### 8.1.1. 例题1 求Fibonacci数列第n项

```c
int f(int n ){
    if(n == 0 || n == 1) return n;
    return f(n - 1) + f(n - 2);
}
```

计算过程中存在冗余计算,为除去冗余计算可以从已知条件开始计算,并记录计算过程中的中间结果.

![image-20210428214856114](/assets/img/ProgII/image-20210428214856114.png)

去除冗余:

```c++
int f[n + 1];
f[1] = f[2] = 1;
int i;
for(i = 3; i < n; i ++)
    f[i] = f[i - 1] + f[i - 2];
cout << f[n] << endl;
```

用空间换时间->动态规划

## 8.2. 例题2 数字三角形

- 问题描述

  在上面的数字三角形中寻找一条从顶部到底边的路径,使得路径上所经过的数字之和最大.路径上的每一步都只能往左下或右下走.只需要求出这个最大和即可,不必给出具体路径.

  三角形的行数$$n:1\le n\le100$$,数字为0-99
  
- 输入样例

  ```
  5 //三角形行数.下面是三角形
  7
  3 8
  8 1 0
  2 7 4 4 
  4 5 2 6 5 
  ```

- 要求输出最大和

- 解题思路:

  以`D(r,j)`表示第r行第j个数字,以`MaxSum(r,j)`代表从第r行的第j个数字到底边的各条路径中,数字之和最大的那条路径的数字之和,则本题是要求`MaxSum(0,0)`.(假设行编号和一行内数字编号都从0开始)

  **典型的动态规划问题.**从某个`D(r,j)`出发,显然下一步只能走`D(r+1,j)`或者`D(r+1,j+1)`,所以,对于N行的三角形:

  ```c
  if (r == N-1)    
  	MaxSum(r, j) = D(N-1, j);
  else 
      MaxSum(r, j) = Max(MaxSum(r＋1, j), 
  			MaxSum(r+1, j+1) ) + D(r,j);
  
  ```

  - 递归程序

    ```c++
    #include <iostream.h> 
    #define MAX 101 
    int triangle[MAX][MAX]; 
    int n; 
    int longestPath(int i, int j); 
    int main(){ 
    　int i,j; 
    　cin >> n; 
    　for(i=0;i<n;i++) for(j=0;j<=i;j++) 
    　　cin >> triangle[i][j]; 
    　cout << longestPath(0,0) << endl; 
    }
    int longestPath(int i, int j){ 
    　if(i==n) return 0; 
    　int x = longestPath(i+1,j); 
    　int y = longestPath(i+1,j+1); if(x<y) x=y; return x+triangle[i][j]; 
    }
    ```

    :warning:**超时!!**

    - 为什么超时?
      - 重复计算
      - 如果采用递规的方法,深度遍历每条路径,则时间复杂度为2^n^,存在大量重复计算.对于`n = 100`,肯定超时.

  - 改进思想:

    从下往上计算,对于每一点,只需要保留从下面来的路径中和最大的路径的和即可.因为在它上面的点只关心到达它的最大路径和,不关心它从那条路经上来的.

    1. 解法1:

       如果每算出一个`MaxSum(r,j)`就保存起来,则可以用时间$$\mathcal{O}(n^2)$$完成计算.因为三角形的数字总数是$$\displaystyle\frac{n(n+1)}2$$

       此时需要的存储空间是:

       `int D[100][100];`用于存储三角形中的数字

       `int aMaxSum [100][100];`用于存储每个`MaxSum(r,j)`

       ```c
       #include <stdio.h>
       #define MAX_NUM 100
       int D[MAX_NUM + 10][MAX_NUM + 10];  int N;
       int aMaxSum[MAX_NUM + 10][MAX_NUM + 10];
       int main() {
       	int i, j; 
       	scanf("%d", & N); 
       	for( i = 1; i <= N; i ++ ) 
       		for( j = 1; j <= i; j ++ ) 
       			scanf("%d", &D[i][j]);
       	for(  j = 1; j <= N; j ++ )
       		aMaxSum[N][j] = D[N][j];
       	for( i = N ; i > 1 ; i -- ) 
       		for( j = 1; j < i  ; j ++ ) {
       		  if( aMaxSum[i][j] > aMaxSum[i][j+1] )
       		    aMaxSum[i-1][j] = aMaxSum[i][j] + D[i-1][j];
       		  else
       		    aMaxSum[i-1][j] = aMaxSum[i][j+1] + D[i-1][j];
       		}
       	printf("%d", aMaxSum[1][1]);
       }
       ```

    2. 解法2:

       没必要用二维`Sum`数组存储每一个`MaxSum(r,j)`,只要从底层一行行向上递推,那么只要一维数组`Sum[100]`即可,即只要存储一行的`MaxSum`值就可以.

       比解法一改进之处在于节省空间,时间复杂度不变.

       ```c
       #include <stdio.h>
       #define MAX_NUM 100
       int D[MAX_NUM + 10][MAX_NUM + 10];  int N;
       int aMaxSum[MAX_NUM + 10];
       int main() {
       	int i, j; 
       	scanf("%d", & N); 
       	for( i = 1; i <= N; i ++ ) 
       		for( j = 1; j <= i; j ++ ) 
       			scanf("%d", &D[i][j]);
       	for(  j = 1; j <= N; j ++ )
       		aMaxSum[j] = D[N][j];
       	for( i = N ; i > 1 ; i -- ) 
       		for( j = 1; j < i  ; j ++ ) {
       		  if( aMaxSum[j] > aMaxSum[j+1] )
       		    aMaxSum[j] = aMaxSum[j] + D[i-1][j];
       		  else
       		    aMaxSum[j] = aMaxSum[j+1] + D[i-1][j];
       		}
       	printf("%d", aMaxSum[1]);
       }
       ```

## 8.3. 递归转动态的一般方法

- 原来的递归函数有几个参数,就定义一个几维的数组,数组的下标是递归函数参数的取值范围,数组元素的值是递归函数的返回值,这样就可以从边界开始,逐步填充数组,相当于计算递归函数值的逆过程.

## 8.4. 例题3 最长上升子序列

- 问题描述

  - 一个数的序列$$\{b_i\}$$,当$$b_1<b_2<\cdots<b_S$$时,我们称这个序列是上升的.
  - 对于给定的一个序列$$\{a_1,a_2,\cdots,a_N\}$$,我们可以得到一些上升的子序列$$\{a_{i_1},a_{i_2},\cdots,a_{i_K}\}$$,这里$$1\le i_1<i_2<\cdots<i_K\le N$$
  - 比如,对于序列$$\{1, 7, 3, 5, 9, 4, 8\}$$,有它的一些上升子序列,如$$\{1,7\}$$,$$\{3,4,8\}$$等等.这些子序列中最长的长度是4,比如子序列$$\{1,3,5,8\}$$. 
  - 你的任务,就是对于给定的序列,求出最长上升子序列的长度.

- 输入

  输入的第一行是序列的长度N($$1\le N\le1000$$).第二行给出序列中的N个整数,这些整数的取值范围都在0到10000.

- 输出

  最长上升子序列的长度.

- 样例

  - 样例输入

    ```
    7
    1 7 3 5 9 4 8
    ```

  - 样例输出

    ```
    4
    ```

- 解题思路

  1. 找子问题
  
     经过分析,发现"求以$$a_k(k=1,2,3,\cdots,N)$$为终点的最长上升子序列的长度"是个好的子问题--这里把一个上升子序列中最右边的那个数,称为该子序列的"终点".虽然这个子问题和原问题形式上并不完全一样,但是只要这N个子问题都解决了,那么这N个子问题的解中,最大的那个就是整个问题的解.
  
  2. 确定状态
  
     上所述的子问题只和一个变量相关,就是数字的位置.因此序列中数的位置k就是"状态",而状态k对应的"值",就是以a~k~做为"终点"的最长上升子序列的长度.这个问题的状态一共有N个.
  
  3. 找出状态转移方程
  
     状态定义出来后,转移方程就不难想了.假定`MaxLen(k)`表示以a~k~做为"终点"的最长上升子序列的长度,那么:
     $$
     \begin{aligned}
     &\text{MaxLen}(1)=1\\
     &\text{MaxLen}(k)=\max\{\text{MaxLen}(i)\left|1<i<k\quad\text{and}\quad a_i<a_k\quad\text{and}\quad k\not=1\right.\}+1
     \end{aligned}
     $$
     这个状态转移方程的意思就是,`MaxLen(k)`的值,就是在a~k~左边,"终点"数值小于a~k~,且长度最大的那个上升子序列的长度再加1.因为a~k~左边任何"终点"小于a~k~的子序列,加上a~k~后就能形成一个更长的上升子序列.
     
     实际实现的时候,可以不必编写递归函数,因为从`MaxLen(1)`就能推算出`MaxLen(2)`,有了`MaxLen(1)`和`MaxLen(2)`就能推算出`MaxLen(3)`....
  
- 解法

  ```c
  #include <stdio.h>
  #include <memory.h>
  #define MAX_N 1000
  int b[MAX_N + 10];
  int aMaxLen[MAX_N + 10];
  int main()
  {	
  	int N;
  	scanf("%d", & N);
  	for( int i = 1;i <= N;i ++ )
  		scanf("%d", & b[i]);
  	aMaxLen[1] = 1;
  	for( i = 2; i <= N; i ++ ) { 
  		//每次求以第i个数为终点的最长上升子序列的长度
  		int nTmp = 0;  //记录满足条件的,第i个数左边的上升子序列的最大长度
  		for( int j = 1; j < i; j ++ ) { //察看以第j个数为终点的最长上升子序列
  			if( b[i] > b[j] ) { 
  				if( nTmp < aMaxLen[j] )
  					nTmp = aMaxLen[j];
  			}
  		}
  		aMaxLen[i]  = nTmp + 1;
  	}
  	int nMax = -1;
  	for( i = 1;i <= N;i ++ )
  		if( nMax < aMaxLen[i])
  			nMax = aMaxLen[i];
  	printf("%d\n", nMax);
  }
  ```

## 8.5. 例题4 Help Jimmy

- 问题描述:

  "Help Jimmy"是在下图所示的场景上完成的游戏:

  ![image-20210428222304710](/assets/img/ProgII/image-20210428222304710.png)

  场景中包括多个长度和高度各不相同的平台.地面是最低的平台,高度为零,长度无限.

  Jimmy老鼠在时刻0从高于所有平台的某处开始下落,它的下落速度始终为1米/秒.

  当Jimmy落到某个平台上时,游戏者选择让它向左还是向右跑,它跑动的速度也是1米/秒.

  当Jimmy跑到平台的边缘时,开始继续下落.

  Jimmy每次下落的高度不能超过MAX米,不然就会摔死,游戏也会结束.

  设计一个程序,计算Jimmy到地面时可能的最早时间.

- 输入

  第一行是测试数据的组数`t`($$0\le t\le20$$).每组测试数据的第一行是四个整数`N`,`X`,`Y`,`MAX`,用空格分隔.`N`是平台的数目(不包括地面),`X`和`Y`是Jimmy开始下落的位置的横竖坐标,`MAX`是一次下落的最大高度.

  接下来的N行每行描述一个平台,包括三个整数:`X1[i]`,`X2[i]`和`H[i]`.`H[i]`表示平台的高度,`X1[i]`和`X2[i]`表示平台左右端点的横坐标.$$1\le N\le1000,-20000\le \text{X,X1[i],X2[i]}\le 20000,0\le\text{H[i]}\le20000\quad(i=1,\cdots,N)$$.

  所有坐标的单位都是米. 

  Jimmy的大小和平台的厚度均忽略不计.如果Jimmy恰好落在某个平台的边缘.被视为落在平台上.

  所有的平台均不重叠或相连.

  测试数据保证Jimmy一定能安全到达地面.

- 输出

  对输入的每组测试数据,输出一个整数,Jimmy到地面时可能的最早时间.

- 样例

  - 样例输入

    ```
    1
    3 8 17 20
    0 10 8
    0 10 13
    4 14 3
    ```

  - 样例输出

    ```
    23
    ```

- 解题思路

  Jimmy跳到一块板上后,可以有两种选择,向左走,或向右走.走到左端和走到右端所需的时间,是很容易算的.如果我们能知道,以左端为起点到达地面的最短时间,和以右端为起点到达地面的最短时间,那么向左走还是向右走,就很容选择了.因此,整个问题就被分解成两个子问题,即Jimmy所在位置下方第一块板左端为起点到地面的最短时间,和右端为起点到地面的最短时间.这两个子问题在形式上和原问题是完全一致的.将板子从上到下从1开始进行无重复的编号(越高的板子编号越小,高度相同的几块板子,哪块编号在前无所谓),那么,和上面两个子问题相关的变量就只有板子的编号.不妨认为Jimmy开始的位置是一个编号为0,长度为0的板子,假设`LeftMinTime(k)`表示从k号板子左端到地面的最短时间,`RightMinTime(k)`表示从k号板子右端到地面的最短时间,那么,求板子k左端点到地面的最短时间的方法如下:

  ```c
  if ( 板子k左端正下方没有别的板子) {
  	if( 板子k的高度 h(k) 大于Max)
  		LeftMinTime(k) = ∞;
  	else
  		LeftMinTime(k) = h(k);
  }
  else if( 板子k左端正下方的板子编号是m ) 
  	LeftMinTime(k) = h(k)-h(m) + 
        Min( LeftMinTime(m) + Lx(k)-Lx(m),  
             RightMinTime(m) + Rx(m)-Lx(k));
  }
  ```

  上面,`h(i)`就代表i号板子的高度,`Lx(i)`就代表i号板子左端点的横坐标,`Rx(i)`就代表i号板子右端点的横坐标.那么`h(k)-h(m)`当然就是从k号板子跳到m号板子所需要的时间,`Lx(k)-Lx(m)`就是从m号板子的落脚点走到m号板子左端点的时间,`Rx(m)-Lx(k)`就是从m号板子的落脚点走到右端点所需的时间.

  求`RightMinTime(k)`的过程类似.

  不妨认为Jimmy开始的位置是一个编号为0,长度为0的板子,那么整个问题就是要求`LeftMinTime(0)`.

  **输入数据中,板子并没有按高度排序,所以程序中一定要首先将板子排序.**

  <u>参考程序:教材P204</u>

## 8.6. 例题5 最佳加法表达式

- 问题描述

  有一个由1..9组成的数字串.问如果将m个加号插入到这个数字串中,在各种可能形成的表达式中,值最小的那个表达式的值是多少

- 解题思路

  假定数字串长度是n,添完加号后,表达式的最后一个加号添加在第i个数字后面,那么整个表达式的最小值,就等于在前i个数字中插入m–1个加号所能形成的最小值,加上第i+1到第n个数字所组成的数的值.

  设`V(m,n)`表示在n个数字中插入m个加号所能形成的表达式最小值,那么:

  ```c
  if m = 0
  	V(m,n) = n个数字构成的整数
  else if n < m + 1
  	V(m,n) = ∞
  else
      V(m,n) = Min{  V(m-1,i) + Num(i+1,n) } ( i = m,...,n-1)
  ```

`Num(k,j)`表示从第k个字符到第j个字符所组成的数

数字编号从1开始算

---



# 9. 

